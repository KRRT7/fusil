#!/usr/bin/env python
"""
Generate Python source code: random function calls with random arguments.
Use "python" command line program.

Interesting modules: all modules written in C or having some code written
in C, see Modules/*.c in Python source code.
"""

import inspect
import pkgutil
import re
import sys
import warnings
from optparse import OptionGroup
from os.path import exists as path_exists, isabs, sep as path_sep
from random import choice, randint, sample
from types import BuiltinFunctionType, FunctionType, ModuleType

from ptrace.os_tools import RUNNING_PYTHON3

from fusil.application import Application
from fusil.bytes_generator import BytesGenerator
from fusil.process.create import CreateProcess
from fusil.process.stdout import WatchStdout
from fusil.process.watch import WatchProcess
from fusil.project_agent import ProjectAgent
from fusil.six import string_types, text_type
from fusil.unicode_generator import (
    ASCII8,
    DECIMAL_DIGITS,
    LETTERS,
    PRINTABLE_ASCII,
    UNICODE_65535,
    IntegerGenerator,
    IntegerRangeGenerator,
    UnicodeGenerator,
    UnixPathGenerator,
    UnsignedGenerator,
)
from fusil.write_code import WriteCode

if not RUNNING_PYTHON3:
    from sys import getfilesystemencoding


# Fuzzer options
IGNORE_TIMEOUT = True
IGNORE_CPU = True
SHOW_STDOUT = False
DEBUG = False

xrange = range

print(sys.version)

# Constants
TIMEOUT = 100.0
PYTHON = sys.executable
FILENAMES = "/etc/machine-id,/bin/sh"
PARSE_PROTOTYPE = True
PROTOTYPE_REGEX = re.compile(r"[A-Za-z]+[A-Za-z_0-9]*\(([^)]*)\)", re.MULTILINE)

MODULE_BLACKLIST = {
    "getpass",
    "commands",
    "subprocess",
    "antigravity",
    "compileall",
    "user",
    "this",
    "_testcapi",
    "_testlimitedcapi",
    "_testinternalcapi",
    "test",
    "ctypes",
    "_ctypes",
    "fusil",
    "ptrace",
    "pip",
    "setuptools",
    "distutils",
    "_signal",
    "signal",
    "__builtin__",
}

CTYPES = {
    "PyObj_FromPtr",
    "string_at",
    "wstring_at",
    "call_function",
    "call_cdeclfunction",
    "Py_INCREF",
    "Py_DECREF",
    "dlsym",
    "dlclose",
    "_string_at_addr",
    "_wstring_at_addr",
    "dlopen",
}

SOCKET = {
    "gethostbyname",
    "gethostbyname_ex",
    "gethostbyaddr",
    "getnameinfo",
    "getaddrinfo",
    "socket",
    "SocketType",
}

POSIX = {
    "_exit",
    "abort",
    "read",
    "ftruncate",
    "rmdir",
    "unlink",
    "kill",
    "killpg",
    "fork",
    "forkpty",
    "system",
    "popen",
    "popen2",
    "popen3",
    "popen4",
    "spawnl",
    "spawnle",
    "spawnlp",
    "spawnlpe",
    "spawnv",
    "spawnve",
    "spawnvp",
    "spawnvpe",
    "execl",
    "execle",
    "execlp",
    "execlpe",
    "execv",
    "execve",
    "execvp",
    "execvpe",
    "wait",
    "wait3",
    "waitpid",
    "tcsetpgrp",
    "closerange",
}

BUILTINS = {"pow", "round"}

# Functions and methods blacklist. Format:
#   module name => function and class names
# and
#    module name:class name => method names
BLACKLIST = {
    # Dangerous module: ctypes
    "ctypes": CTYPES,
    "_ctypes": CTYPES,
    # Eat a lot of CPU with large arguments
    "itertools": {"tee"},
    "math": {"factorial"},
    "operator": {
        "pow",
        "__pow__",
        "ipow",
        "__ipow__",
        "mul",
        "__mul__",
        "repeat",
        "__repeat__",
    },
    "__builtin__": BUILTINS,
    "builtins": BUILTINS,
    # Don't raise SystemError
    "_builtin__:set": {"test_c_api"},
    "builtins:set": {"test_c_api"},
    # Sleep
    "time": {"sleep", "pthread_getcpuclockid"},
    "select": {"epoll", "poll", "select"},
    "signal": {"pause", "alarm", "setitimer", "pthread_kill"},
    "_signal": {"pause", "alarm", "setitimer", "pthread_kill"},
    "_socket": SOCKET,
    "socket": SOCKET,
    "posix": POSIX,
    "os": POSIX,
    "_fileio:_FileIO": {"read", "readall"},
    # timeout
    "multiprocessing": {"Pool"},
    "_multiprocessing:SemLock": {"acquire"},
    "_multiprocessing:Connection": {"recv", "recv_bytes", "poll"},
    "_tkinter": {"dooneevent", "create", "mainloop"},
    "termios": {"tcflow"},
    "dl": {"open"},
    "pydoc": {"serve", "doc", "apropos"},
    # listen to a socket and wait for requests
    "BaseHTTPServer": {"test"},
    "CGIHTTPServer": {"test"},
    "SimpleHTTPServer": {"test"},
    "pprint": {"_perfcheck"},  # timeout (unlimited loop?)
    "tabnanny": {"check"},  # python 2.5.2 implementation is just slow
    # create child process
    "popen2": {"popen2", "popen3", "popen4", "Popen3", "Popen4"},
    "pty": {"fork", "spawn"},
    "platform": {"_syscmd_uname"},
    # avoid false positive with pattern on stdout
    "logging": {"warning", "error", "fatal", "critical"},
    "formatter": {"test"},
    # Create huge integer, very long string or list
    "fpformat": {"fix"},
    # remove directory
    "shutil": {"copytree", "rmtree"},
    # open a network connection (timeout)
    # FIXME: only blacklist the blocking methods, not the whole class?
    "imaplib": {"IMAP4", "IMAP4_stream"},
    "telnetlib": {"Telnet"},
    "nntplib": {"NNTP"},
    "smtplib": {"SMTP", "SMTP_SSL"},
    # open a network connection (timeout),
    # the constructor opens directly a connection
    "poplib": {"POP3", "POP3_SSL"},
    "ftplib": {"FTP", "FTP_TLS"},
    # set resource limit, may stop the process:
    # setrlimit(RLIMIT_CPU, (0, 0)) kills the process with a SIGKILL signal
    "resource": {"setrlimit"},
    "xmllib": {"test"},  # timeout
    "urllib2": {"randombytes"},  # unlimited loop
    "py_compile": {"compile"},
    "runpy": {"run_path"},
    "faulthandler": {
        "_fatal_error",
        "_read_null",
        "_sigabrt",
        "_sigbus",
        "_sigfpe",
        "_sigill",
        "_sigsegv",
        "_stack_overflow",
    },
    # TODO: blacklist distutils/spawn.py (35): spawn
    # TODO: blacklist distutils/spawn.py (121): _spawn_posix
}

# Currently we have to import all C modules before running the fuzzer.
# TODO: figure out why and fix it properly.
for name in sys.stdlib_module_names:
    if name not in MODULE_BLACKLIST and "test" not in name:
        try:
            sys.modules[name] = __import__(name)
        except ImportError as e:
            print("Failed to import module %s\n" % name, e)

if DEBUG:
    NB_CALL = 5
    NB_METHOD = 1
    NB_CLASS = 5
else:
    NB_CALL = 250
    NB_METHOD = 15
    NB_CLASS = 50
MAX_ARG = 6
MAX_VAR_ARG = 5

if RUNNING_PYTHON3:
    SURROGATES = (
        '"\\x00"',
        '"\\x00"',
        '"\\x00"',
        '"\\x00"',
        '"\\uDC80"',
        '"\\uDC80"',
        '"\\U0010FFFF"',
        '"\\U0010FFFF"',
        '"\\udbff\\udfff"',
    )

    BUFFER_OBJECTS = (
        'bytearray(b"abc\\xe9\\xff")',
        'memoryview(b"abc\\xe9\\xff")',
        'memoryview(bytearray(b"abc\\xe9\\xff"))',
    )
else:
    SURROGATES = (
        'u"\\uDC80"',
        'u"\\uDC80"',
        'u"\\U0010FFFF"',
        'u"\\udbff\\udfff"',
    )

    BUFFER_OBJECTS = ('buffer("abc\\xe9\\xff")',)

INTERESTING = (
    # Large integer boundaries
    "sys.maxsize",  # Maximum integer size for current platform
    "sys.maxsize - 1",  # One below maximum integer size
    "sys.maxsize + 1",  # One above maximum integer size (overflow test)
    "-sys.maxsize",  # Negative maximum integer boundary
    "2 ** 63 - 1",  # 64-bit integer boundary (signed max for 64-bit)
    "-2 ** 63",  # 64-bit integer boundary (signed min for 64-bit)
    "2 ** 31 - 1",  # 32-bit integer boundary (signed max for 32-bit)
    "-2 ** 31",  # 32-bit integer boundary (signed min for 32-bit)
    # Large powers and exponential values
    "10 ** (sys.int_info.default_max_str_digits + 1)",  # Overflow of typical max digit handling
    "10 ** 100",  # Extremely large integer to test overflow and precision
    "-10 ** (sys.int_info.default_max_str_digits)",  # Large negative integer boundary
    "10 ** (sys.int_info.default_max_str_digits + 2)",  # Further max digit overflow test
    # Floating-point boundaries and edge cases
    'float("nan")',  # NaN, tests handling of undefined floats
    'float("inf")',  # Positive infinity
    'float("-inf")',  # Negative infinity
    "sys.float_info.epsilon",  # Smallest positive float greater than zero
    "sys.float_info.max",  # Maximum representable float
    "sys.float_info.min",  # Minimum positive float
    "-sys.float_info.max",  # Negative maximum float
    "-sys.float_info.epsilon",  # Negative epsilon (smallest magnitude negative float)
    "sys.float_info.min / 2",  # Value close to underflow boundary
    "-sys.float_info.min / 2",  # Negative value close to underflow boundary
    'float("0.0000001")',  # Very small float, near zero
    '-float("0.0000001")',  # Very small negative float, near zero
    # Complex numbers with extreme values
    "complex(sys.maxsize, sys.maxsize)",  # Large complex number with large real and imaginary parts
    'complex(float("inf"), float("nan"))',  # Complex with infinity and NaN
    "complex(sys.float_info.max, sys.float_info.epsilon)",  # Mix of large and tiny parts in complex
    "1j",  # Small complex number with imaginary unit
    "-1j",  # Negative small complex number with imaginary unit
    # Unicode and string boundary tests
    "chr(0)",  # Null character
    "chr(127)",  # Edge of ASCII range
    "chr(255)",  # Edge of extended ASCII range
    "chr(0x10FFFF)",  # Maximum Unicode code point
    r'"\uDC80"',  # Unpaired surrogate, tests encoding robustness
    '"ùíú"',  # Surrogate pair in UTF-16
    r'"\x00" * 10',  # Null byte sequence
    '"A" * (2 ** 16)',  # Large string boundary (typical buffer size)
    '"üíª" * 2**10',  # Large string with multibyte Unicode characters
    # Boolean and None values
    "True",  # Basic boolean value
    "False",  # Basic boolean value
    "None",  # None, tests for null handling
    # Pathological data structures
    "[]",  # Empty list
    "[[]]",  # Nested empty list
    "[[[]]]",  # Deeply nested empty list
    "{0: {0: {0: {}}}}",  # Deeply nested dictionary
    '[(None, 1, "a") for _ in range(2**10)]',  # Large list with mixed types
    "[[1] * 10] * 10",  # Nested lists with shared references
    'bytearray(b"")',  # Empty byte array
    'bytearray(b"A" * 2**10)',  # Moderately large byte array
    # Bytes and encoded data
    "bytes(10 ** 5)",  # Large empty bytes sequence
    "bytes(range(256))",  # Full byte range, all possible byte values
    r'b"\x00" * (2**16)',  # Maximum byte array handling with null bytes
    'memoryview(b"A" * 2**8)',  # Memory view around a moderately large byte array
    # Regular expressions and raw strings
    'r"^(?:a|aa)*$"',  # Complex regex pattern
    r'r"\A[\w-]+\Z"',  # Simple regex pattern
    r'r"\d{1,100}"',  # Large quantifier regex pattern
    # Lambda and object instances
    "lambda: None",  # Simple lambda function (tests function call handling)
    "(lambda x: sys.maxsize)",  # Lambda with boundary value as output
    "object()",  # Base object with minimal attributes
    "frozenset({sys.maxsize, -sys.maxsize})",  # Immutable set with boundary values
    # Other encoding and integer tests
    '"A" * (2**10)',  # Large simple string
    "complex(-10 ** 10, 10 ** 10)",  # Complex number with extreme real and imaginary values
    "(sys.maxunicode + 1,)",  # Beyond max Unicode
)


class ListAllModules:
    def __init__(self, logger, only_c, site_package, blacklist):
        self.logger = logger
        self.only_c = only_c
        self.site_package = site_package
        self.blacklist = blacklist
        self.names = set(sys.builtin_module_names) - {"__main__"}

    def matchModule(self, is_package, name, filename):
        if filename is not None and not self.filter_filename(filename):
            return False
        if not self.only_c:
            return True
        if is_package:
            return False
        if any(
            filename.endswith(ext)
            for ext in (".py", ".pyc", ".pyo")
            if filename is not None
        ):
            return False
        return True

    def filter_filename(self, filename):
        if not self.site_package:
            if "site-packages" in filename.split(path_sep):
                return False
        return True

    def walk_packages(self, path=None, prefix="", onerror=None):
        def seen(p, m={}):
            if p in m:
                return True
            m[p] = True

        for info in pkgutil.iter_modules(path, prefix):
            path = package = None
            if info.name in sys.modules:
                path = getattr(sys.modules[info.name], "__path__", None)
                package = getattr(sys.modules[info.name], "__package__", None)
            if (
                "test" in info.name
                or "pip" in info.name
                or (path is not None and any("site-packages" in p for p in path))
                or (package is not None and "pip" in package)
            ):
                print("SKIPPED", info, file=sys.stderr)
                continue
            yield info

            if info.ispkg:
                try:
                    __import__(info.name)
                except ImportError:
                    if onerror is not None:
                        onerror(info.name)
                except Exception:
                    if onerror is not None:
                        onerror(info.name)
                    else:
                        raise
                else:
                    if info.name in sys.modules:
                        path = getattr(sys.modules[info.name], "__path__", None) or []
                        # don't traverse path items we've seen before
                        path = [p for p in path if not seen(p)]
                        yield from self.walk_packages(path, info.name + ".", onerror)

    def search_modules(self, path, prefix):
        if path is not None and not self.site_package:
            path = [name for name in path if self.filter_filename(name)]
            if not path:
                return
        try:
            for loader, name, is_package in self.walk_packages(
                None, onerror=lambda x: None
            ):
                if name.endswith("_d"):
                    # Ignore Debian debug modules
                    # (e.g. ignore "_bisect_d", the real module is "_bisect)
                    continue
                if (
                    name in self.blacklist
                    or prefix in self.blacklist
                    or prefix.split(".")[0] in self.blacklist
                    or name.split(".")[0] in self.blacklist
                    or "test" in name
                    or "idlelib" in name
                ):
                    # Ignore the module and all of its submodules
                    self.logger.error(f"IGNORED {prefix}:{name}")
                    continue
                fullname = prefix + name
                if self.only_c:
                    module = None
                    if fullname in sys.modules:
                        module = sys.modules[fullname]
                    elif name in sys.modules:
                        module = sys.modules[name]
                    elif name.split(".")[0] in sys.modules:
                        module = sys.modules[name.split(".")[0]]
                    elif prefix in sys.modules:
                        module = sys.modules[prefix]
                    elif prefix.split(".")[0] in sys.modules:
                        module = sys.modules[prefix.split(".")[0]]
                    if module and hasattr(module, "__file__"):
                        if module.__file__.endswith(("py", "pyo", "pyc", "pyw")):
                            self.logger.error(f"SKIP PYTHON MODULE {fullname}")
                            continue
                self.logger.error(f"ADDING {fullname}: {prefix}+{name}")
                self.names.add(fullname)
        except:
            raise

    def search(self):
        self.search_modules(None, "")
        return self.names


class Fuzzer(Application):
    NAME = "python"

    def createFuzzerOptions(self, parser):
        options = OptionGroup(parser, "Python fuzzer")
        options.add_option(
            "--modules",
            help="Tested Python module names separated by commas (default: test all modules)",
            type="str",
            default="*",
        )
        options.add_option(
            "--blacklist",
            help='Module blacklist separated by commas (eg. "_lsprof,_json")',
            type="str",
        )
        options.add_option(
            "--test-private",
            help="Test private methods (default: skip privates methods)",
            action="store_true",
        )
        options.add_option(
            "--timeout",
            help="Timeout in seconds (default: %.1f)" % TIMEOUT,
            type="float",
            default=TIMEOUT,
        )
        options.add_option(
            "--filenames",
            help="Names separated by commas of readable files (default: %s)"
            % FILENAMES,
            type="str",
            default=FILENAMES,
        )
        options.add_option(
            "--python",
            help="Python executable program path (default: %s)" % PYTHON,
            type="str",
            default=PYTHON,
        )
        options.add_option(
            "--only-c",
            help="Only search for modules written in C (default: search all module)",
            action="store_true",
        )
        options.add_option(
            "--no-site-packages",
            help="Don't search modules in site-packages directory",
            action="store_true",
        )
        return options

    def setupProject(self):
        project = self.project

        project.error("Use python interpreter: %s" % self.options.python)
        version = " -- ".join(line.strip() for line in sys.version.splitlines())
        project.error("Python version: %s" % version)
        PythonSource(project, self.options)
        process = PythonProcess(
            project,
            [self.options.python, "-u", "<source.py>"],
            timeout=self.options.timeout,
        )
        process.max_memory = 4000 * 1024 * 1024
        options = {"exitcode_score": 0}
        if IGNORE_TIMEOUT:
            options["timeout_score"] = 0
        watch = WatchProcess(process, **options)
        if watch.cpu and IGNORE_CPU:
            watch.cpu.max_score = 0

        stdout = WatchStdout(process)
        stdout.max_nb_line = None

        # Disable dummy error messages
        stdout.words = {
            "oops": 0.30,
            "bug": 0.10,
            "fatal": 0.1,
            "assert": 0.025,
            "assertion": 1.0,
            "critical": 1.0,
            "panic": 1.0,
            "glibc detected": 1.0,
            "segfault": 1.0,
            "segmentation fault": 1.0,
            "SystemError": 1.0,
        }

        # CPython critical messages
        stdout.addRegex("^XXX undetected error", 1.0)
        stdout.addRegex("Fatal Python error", 1.0)
        # Match "Cannot allocate memory"?

        # PyPy messages
        stdout.addRegex("Fatal RPython error", 1.0)

        if SHOW_STDOUT or DEBUG:
            stdout.show_matching = True
            stdout.show_not_matching = True

        # avoid matching on "assert" keyword
        stdout.ignoreRegex(r"ast\.Assert()")

        # PyPy interact prompt
        # avoid false positive on "# assert did not crash"
        stdout.ignoreRegex(r"^And now for something completely different:")

        # Hide Python warnings on import
        warnings.simplefilter("ignore")


ERRBACK_NAME = "errback"

METHODS_NB_ARG = {
    "__str__": 0,
    "__repr__": 0,
    "__hash__": 0,
    "__reduce__": 0,
    "__delattr__": 1,
    "__getattribute__": 1,
    "__getitem__": 1,
    "__getslice__": 2,
    "__reduce_ex__": (0, 1),
    "__getstate__": 0,
    "__setattr__": 2,
    "__setstate__": 1,
    "__eq__": 1,
    "__lt__": 1,
    "__gt__": 1,
    "__add__": 1,
    "__sub__": 1,
    "__mul__": 1,
    "__div__": 1,
    "__lshift__": 1,
    "__iadd__": 1,
    "__isub__": 1,
    "__imul__": 1,
    "__idiv__": 1,
    "__getattr__": 1,
    "__ge__": 1,
    "__le__": 1,
    "__ne__": 1,
    "__sizeof__": 0,
    "__reversed__": 0,
    "__contains__": 1,
    "__iter__": 0,
    "__setitem__": 2,
    "__or__": 1,
    "__ior__": 1,
    "__ror__": 1,
    "__and__": 1,
    "__iand__": 1,
    "__rand__": 1,
    "exec": 3,
}


class PythonFuzzerError(Exception):
    pass


class PythonSource(ProjectAgent):
    def __init__(self, project, options):
        ProjectAgent.__init__(self, project, "python_source")
        self.options = options
        if self.options.modules != "*":
            self.modules = set()
            for module in self.options.modules.split(","):
                module = module.strip()
                if not len(module):
                    continue
                self.modules.add(module)
        else:
            self.error("Search all Python modules...")
            self.modules = ListAllModules(
                self,
                self.options.only_c,
                not self.options.no_site_packages,
                MODULE_BLACKLIST,
            ).search()
        blacklist = self.options.blacklist
        if blacklist:
            blacklist = set(blacklist.split(","))
            removed = self.modules & blacklist
            self.error("Blacklist modules: %s" % removed)
            self.modules = list(self.modules - blacklist)
        self.modules = list(self.modules)
        self.modules.sort()
        self.error("Found %s Python modules" % len(self.modules))
        for name in self.modules:
            self.info("Python module: %s" % name)

        self.filenames = self.options.filenames
        if not RUNNING_PYTHON3:
            encoding = getfilesystemencoding()
            self.filenames = text_type(self.filenames, encoding)
        self.filenames = self.filenames.split(",")
        for filename in self.filenames:
            if not isabs(filename):
                raise ValueError(
                    "Filename %r is not an absolute path! Fix the --filenames option"
                    % filename
                )
            if not path_exists(filename):
                raise ValueError(
                    "File doesn't exist: %s! Use different --filenames option"
                    % filename
                )
        project.error("Use filenames: %s" % ", ".join(self.filenames))

    def loadModule(self, module_name):
        self.module_name = module_name
        self.debug("Import %s" % self.module_name)
        self.module = __import__(self.module_name)
        for name in self.module_name.split(".")[1:]:
            self.module = getattr(self.module, name)
        try:
            self.warning("Module filename: %s" % self.module.__file__)
        except AttributeError:
            pass
        self.write = WritePythonCode(self, self.filename, self.module,
                                     self.module_name, threads=False,
                                     _async=True)

    def on_session_start(self):
        self.filename = self.session().createFilename("source.py")

        # copy sys.modules
        old_sys_modules = sys.modules.copy()

        while self.modules:
            name = choice(self.modules)
            try:
                self.loadModule(name)
                break
            except BaseException as err:
                self.error(
                    "Unable to load module %s: [%s] %s"
                    % (name, err.__class__.__name__, err)
                )
                self.modules.remove(name)
        if not self.modules:
            self.error("There is no more modules!")
            self.send("project_stop")
            return
        self.error("Test module %s" % name)
        self.send("session_rename", name)

        self.write.writeSource()
        self.send("python_source", self.filename)

        # unload new modules
        sys.modules.clear()
        sys.modules.update(old_sys_modules)


class PythonProcess(CreateProcess):
    def on_python_source(self, filename):
        self.cmdline.arguments[-1] = filename
        self.createProcess()


# >'<, >"<, >\<
ESCAPE_CHARACTERS = "'" + '"' + "\\"


def formatCharacter(char):
    if char in ESCAPE_CHARACTERS:
        # >\"<
        return "\\" + char
    code = ord(char)
    if 32 <= code <= 126:
        # >a<
        return char
    elif code <= 255:
        # >\xEF<
        return "\\x%02X" % code
    elif code <= 65535:
        # >\u0101<
        return "\\u%04X" % code
    else:
        # >\U00010FA3<
        return "\\U%08X" % code


def escapeUnicode(text):
    return "".join(formatCharacter(char) for char in text)


class WritePythonCode(WriteCode):
    def __init__(self, parent, filename, module, module_name, threads=True, _async=True):
        WriteCode.__init__(self)
        self.filename = filename
        self.filenames = parent.filenames
        self.options = parent.options
        self.threads = threads
        self._async = _async
        self.hashable_argument_generators = (
            self.genNone,
            self.genBool,
            self.genSmallUint,
            self.genInt,
            self.genLetterDigit,
            self.genBytes,
            self.genString,
            self.genSurrogates,
            self.genAsciiString,
            self.genUnixPath,
            self.genFloat,
            self.genExistingFilename,
            self.genErrback,
            #            self.genOpenFile,
            self.genException,
            self.genRawString,
        )
        self.simple_argument_generators = self.hashable_argument_generators + (
            self.genBufferObject,
            self.genInterestingValues,
        )
        self.complex_argument_generators = (
            self.genList,
            self.genTuple,
            self.genDict,
            self.genTricky,
            self.genInterestingValues,
        )
        self.smallint_generator = IntegerRangeGenerator(-19, 19)
        self.int_generator = IntegerGenerator(20)
        self.bytes_generator = BytesGenerator(0, 20)
        self.unicode_generator = UnicodeGenerator(1, 20, UNICODE_65535)
        self.ascii_generator = UnicodeGenerator(0, 20, ASCII8)
        self.unix_path_generator = UnixPathGenerator(100)
        self.letters_generator = UnicodeGenerator(
            1, 8, LETTERS | DECIMAL_DIGITS | ASCII8
        )
        self.float_int_generator = IntegerGenerator(4)
        self.float_float_generator = UnsignedGenerator(4)
        self.module = module
        self.module_name = module_name

        self.functions, self.classes, self.objects = self.getFunctions()
        if not self.functions and not self.classes:
            raise PythonFuzzerError(
                "Module %s has no function and no class!" % self.module_name
            )

    def writePrint(self, level, arguments):
        if RUNNING_PYTHON3:
            code = "print (%s, file=stderr)" % arguments
        else:
            code = "print >>stderr, %s" % arguments
        self.write(level, code)

    def writeSource(self):
        self.createFile(self.filename)
        self.write(0, "from gc import collect")
        self.write(0, "from sys import stderr")
        self.write(0, "import sys")
        self.write(0, "from threading import Thread")
        self.write(0, "from unittest.mock import MagicMock")
        self.writePrint(0, '"import %s"' % self.module_name)
        self.write(0, "import %s" % self.module_name)
        self.emptyLine()
        self.write(0, "def %s(*args, **kw):" % ERRBACK_NAME)
        self.write(1, "raise ValueError('error')")
        self.emptyLine()
        if self.threads:
            self.write(0, "alive = []")
        if self._async:
            self.write(0, "_async = []")
        self.write(0, "lst = list(range(10))")
        self.write(0, "lst.append(lst)")
        self.write(0, "class Liar1:")
        self.write(1, "def __eq__(self, other):")
        self.write(2, "return True")
        self.emptyLine()
        self.write(0, "class Liar2:")
        self.write(1, "def __eq__(self, other):")
        self.write(2, "return False")
        self.emptyLine()
        self.write(0, "liar1, liar2 = Liar1(), Liar2()")
        self.emptyLine()
        self.write(
            0,
            "\n\nclass Evil:\n    def __eq__(self, other):\n"
            "        for attr in dir(other):\n"
            "            try:\n"
            "                other.__dict__[attr] = %s\n"
            "            except:\n"
            "                pass\n"
            "evil = Evil()" % ERRBACK_NAME,
        )
        self.emptyLine()
        self.emptyLine()
        self.write(0, "def callMethod(prefix, object, name, *arguments):")
        level = self.addLevel(1)
        self.writeCallMethod()
        self.restoreLevel(level)
        self.emptyLine()

        self.write(0, "def callFunc(prefix, name, *arguments):")
        self.write(
            1, "return callMethod(prefix, %s, name, *arguments)" % self.module_name
        )
        self.emptyLine()

        self.write(0, "obj = %s" % self.module_name)

        self.writeCode(
            "", self.module, self.functions, self.classes, self.objects, 1, NB_CALL
        )
        self.emptyLine()
        if self.threads:
            self.write(0, "for obj in alive:")
            self.write(1, "try:")
            self.write(2, "print('START', obj)")
            self.write(2, "obj.start()")
            self.write(1, "except Exception:")
            self.write(2, "pass")
            self.write(0, "for obj in alive:")
            self.write(1, "try:")
            self.write(2, "print('JOIN', obj)")
            self.write(2, "obj.join()")
            self.write(1, "except Exception:")
            self.write(2, "pass")
            self.emptyLine()
        if self._async:
            self.write(0, "import asyncio")
            self.write(0, "async def main_async():")
            self.write(1, "await asyncio.gather(*_async, return_exceptions=True)")
            self.emptyLine()
            self.write(0, "asyncio.run(main_async())")
            self.emptyLine()
        self.close()

    def writeCallMethod(self):
        self.write(0, 'funcname = "%s.%%s()" %% name' % self.module_name)
        self.write(0, 'message = "[%s] %s" % (prefix, funcname)')
        self.writePrint(0, "message")
        self.write(0, "try:")
        self.write(1, "func = getattr(object, name)")
        self.write(1, "for x in range(2):")
        self.write(2, "result = [func(*arguments) for y in range(20)][0]")

        exceptions = "(Exception, SystemExit, KeyboardInterrupt)"
        if RUNNING_PYTHON3:
            self.write(0, "except %s as err:" % exceptions)
        else:
            self.write(0, "except %s, err:" % exceptions)
        self.write(1, "try:")
        self.write(2, "errmsg = repr(err)")
        self.write(1, "except ValueError as e:")
        self.write(2, "errmsg = repr(e)")
        if RUNNING_PYTHON3:
            self.write(1, "errmsg = errmsg.encode('ASCII', 'replace')")
        self.writePrint(
            1,
            '"[%s] %s => %s: %s" % (prefix, funcname, err.__class__.__name__, errmsg)',
        )
        self.write(1, "result = None")

        self.writePrint(0, '"[%s] -garbage collector-" % prefix')
        self.write(0, "collect()   # explicit call to the garbage collector")
        if self.threads:
            self.write(0, "try:")
            self.write(1, "if result:")
            self.write(2, "alive.append(Thread(target=func, args=arguments))")
            self.write(0, "except:")
            self.write(1, "pass")
        self.write(0, "return result")

    def getFunctions(self):
        classes = []
        functions = []
        objects = []
        try:
            blacklist = BLACKLIST[self.module_name]
        except KeyError:
            blacklist = set()

        names = set(dir(self.module))
        names -= {"__builtins__", "__doc__", "__file__", "__name__"}
        names -= blacklist
        for name in names:
            try:
                attr = getattr(self.module, name)
            except AttributeError:
                # attribute declared in __all__, but no declared?
                continue
            if isinstance(attr, (FunctionType, BuiltinFunctionType)):
                functions.append(name)
            elif isinstance(attr, type) or inspect.isclass(attr):
                classes.append(name)
            else:
                objects.append(name)
        return functions, classes, objects

    def getMethods(self, object, class_name):
        try:
            key = "%s:%s" % (self.module_name, class_name)
            blacklist = BLACKLIST[key]
        except KeyError:
            blacklist = set()
        methods = {}
        if type(object) in {int, str}:
            return methods
        for name in dir(object):
            if name in blacklist:
                continue
            if (not self.options.test_private) and name.startswith("__"):
                continue
            try:
                attr = getattr(object, name, None)
                if attr is None:
                    continue
                if not callable(attr):
                    continue
            except Exception:
                continue
            methods[name] = attr
        return methods

    def _createArgument(self, generators):
        callback = choice(generators)
        value = callback()
        for item in value:
            if not isinstance(item, text_type):
                raise ValueError("%s returned type %s" % (callback, type(item)))
        return value

    def createArgument(self):
        return self._createArgument(self.simple_argument_generators)

    def createHashableArgument(self):
        return self._createArgument(self.hashable_argument_generators)

    def createComplexArgument(self):
        if randint(0, 9) < 9:
            # 10%
            generators = self.complex_argument_generators
        else:
            # 90%
            generators = self.simple_argument_generators
        return self._createArgument(generators)

    def getNbArg(self, func, func_name, min_arg):
        try:
            # Known method of arguments?
            value = METHODS_NB_ARG[func_name]
            if isinstance(value, tuple):
                min_arg, max_arg = value
            else:
                min_arg = max_arg = value
            return min_arg, max_arg
        except KeyError:
            pass

        try:
            argspec = inspect.getfullargspec(func)
            has_self = 1 if "self" in argspec.args or "cls" in argspec.args else 0
            args = (len(argspec.args) - has_self) if argspec.args else 0
            defaults = (len(argspec.defaults) - has_self) if argspec.defaults else 0
            return args - defaults, args
        except TypeError:
            pass

        if PARSE_PROTOTYPE:
            # Try using the documentation
            args = parseDocumentation(func.__doc__, MAX_VAR_ARG)
            if args:
                return args
        return min_arg, MAX_ARG

    def callFunction(self, prefix, func_index, func_name, func, min_arg, obj_name=None):
        if func_name.lower() in {"abort", "systemerror", "fatal", "critical", "assert"}:
            return
        min_arg, max_arg = self.getNbArg(func, func_name, min_arg)

        if randint(0, 19) < 1:
            nb_arg = 0
        elif randint(0, 19) < 2:
            nb_arg = 1
        elif randint(0, 19) < 3:
            nb_arg = max_arg + 1
        elif min_arg == max_arg:
            nb_arg = min_arg
        else:
            nb_arg = randint(min_arg, max_arg)

        if prefix:
            prefix += str(1 + func_index)
            first_line = 'res = callMethod("%s", obj, "%s"' % (prefix, func_name)
        else:
            prefix = "f%s" % (1 + func_index)
            first_line = 'res = callFunc("%s", "%s"' % (prefix, func_name)
        if nb_arg:
            self.write(0, first_line + ",")
            level = self.addLevel(1)
            last_char = ","
            for index in xrange(nb_arg):
                if index == nb_arg - 1:
                    last_char = ")"
                self.writeArgument(1, last_char)
            self.restoreLevel(level)
        else:
            self.write(0, first_line + ")")
        if self.threads:
            first_line = "alive.append(Thread(target=obj.%s, args=(" % (func_name,)
            self.write(0, "if hasattr(obj, '%s'):" % (func_name,))
            if nb_arg:
                self.write(1, first_line)
                last_char = ","
                for index in xrange(nb_arg):
                    if index == nb_arg - 1:
                        last_char = ",)))"
                    self.writeArgument(1, last_char)
            else:
                self.write(1, first_line + ")))")
        if self._async:
            self.emptyLine()
            self.write(0, "async def %s_%s():" % (prefix, func_name))
            self.write(1, "print('Start async calling %s_%s')" % (prefix, func_name))
            first_line = 'obj.%s(' % func_name
            if nb_arg:
                self.write(1, first_line)
                level = self.addLevel(1)
                last_char = ","
                for index in xrange(nb_arg):
                    if index == nb_arg - 1:
                        last_char = ")"
                    self.writeArgument(1, last_char)
                self.restoreLevel(level)
            else:
                self.write(1, first_line + ")")
            self.write(1, "print('End async calling %s_%s')" % (prefix, func_name))

            self.write(0, "_async.append(%s_%s())" % (prefix, func_name))


        self.emptyLine()

    def writeArgument(self, level, last_char=","):
        lines = self.createComplexArgument()
        lines[-1] += last_char
        for line in lines:
            self.write(level, line)

    def useClass(self, cls_index, cls, class_name):
        import inspect

        argspec = inspect.getfullargspec(cls.__init__)
        args = len(argspec.args) - 1 if argspec.args else 0
        defaults = len(argspec.defaults) if argspec.defaults else 0
        nb_arg = randint(args - defaults, args)

        prefix = "o%s" % (1 + cls_index)
        self.writePrint(0, '"[%s] Create object %s"' % (prefix, 1 + cls_index))

        obj_name = "obj"
        self.write(0, '%s = callFunc("%s", "%s",' % (obj_name, prefix, class_name))
        for index in xrange(nb_arg):
            self.write(2, "# argument %s/%s" % (1 + index, nb_arg))
            self.writeArgument(2)
        self.write(1, ")")

        methods = sorted(self.getMethods(cls, class_name).keys())
        if methods:
            self.write(0, "if obj is not None:")
            level = self.addLevel(1)
            self.writeCode(prefix + "m", cls, methods, tuple(), tuple(), 0, NB_METHOD)
            self.write(0, "del %s" % obj_name)
            self.writePrint(0, '"[%s] -garbage collector -"' % prefix)
            self.write(0, "collect()   # explicit call to the garbage collector")
            self.restoreLevel(level)
        self.emptyLine()

    def useObject(self, obj_index, obj, obj_name):
        prefix = "obj%s" % (1 + obj_index)
        self.writePrint(
            0,
            '"[%s] Call methods on object %s (%s)"' % (prefix, 1 + obj_index, obj_name),
        )
        self.write(0, "obj = %s.%s" % (self.module_name, obj_name))
        methods = self.getMethods(obj, obj_name)
        if methods:
            self.write(0, "if obj is not None:")
            level = self.addLevel(1)
            self.writeCode(
                prefix + "m",
                obj,
                sorted(methods.keys()),
                tuple(),
                tuple(),
                0,
                NB_METHOD,
                obj_name,
            )
            self.writePrint(0, '"[%s] -garbage collector -"' % prefix)
            self.write(0, "collect()   # explicit call to the garbage collector")
            self.restoreLevel(level)
        self.emptyLine()

    def writeCode(
        self,
        prefix,
        object,
        functions,
        classes,
        objects,
        func_min_arg,
        nb_call,
        obj_name=None,
    ):
        if functions:
            for index in xrange(nb_call):
                func_name = choice(functions)
                func = getattr(object, func_name)
                self.callFunction(
                    prefix, index, func_name, func, func_min_arg, obj_name
                )
        if classes:
            self.nb_class = NB_CLASS
            for index in xrange(self.nb_class):
                class_name = choice(classes)
                cls = getattr(object, class_name)
                self.useClass(index, cls, class_name)
        if objects:
            for index in xrange(len(objects) * 2):
                object_name = choice(objects)
                obj = getattr(object, object_name)
                if isinstance(obj, ModuleType):
                    continue
                self.useObject(index, obj, object_name)

    def genNone(self):
        return ["None"]

    def genTricky(self):
        return [
            choice(
                [
                    "liar1",
                    "liar2",
                    "lst",
                    "lambda *args, **kwargs: 1/0",
                    "int",
                    "type",
                    "object()",
                    "[[[[[[[[[[[[[[]]]]]]]]]]]]]]",
                    "MagicMock()",
                    "Evil()",
                ]
            )
        ]

    def genBool(self):
        if randint(0, 1) == 1:
            return ["True"]
        else:
            return ["False"]

    def genSmallUint(self):
        return [self.smallint_generator.createValue()]

    def genInt(self):
        return [self.int_generator.createValue()]

    def genBytes(self):
        # Bytes string
        bytes = self.bytes_generator.createValue()
        if RUNNING_PYTHON3:
            text = "".join("\\x%02X" % byte for byte in bytes)
            text = 'b"%s"' % text
        else:
            text = "".join("\\x%02X" % ord(byte) for byte in bytes)
            text = '"%s"' % text
        return [text]

    def genUnixPath(self):
        path = self.unix_path_generator.createValue()
        return ['"%s"' % path]

    def _genUnicode(self, generator):
        # (Unicode) character string
        text = generator.createValue()
        text = escapeUnicode(text)
        if RUNNING_PYTHON3:
            text = '"%s"' % text
        else:
            text = 'u"%s"' % text
        return [text]

    def genLetterDigit(self):
        return self._genUnicode(self.letters_generator)

    def genString(self):
        return self._genUnicode(self.unicode_generator)

    def genRawString(self):
        sequences = (
            [r"\d", r"\D", r"\w", r"\W", r"\s", r"\S", r"\b", r"\B", r"\A", r"\Z"]
            + sorted(LETTERS)
            + ["."] * 10
        )
        special = ["+", "?", "*"]
        result = []
        for x in range(randint(3, 20)):
            result.append("".join(sample(sequences, randint(1, 3))))
            if randint(0, 9) > 8:
                result.append(choice(special))
        return [f'r"{"".join(result)}"']

    def genSurrogates(self):
        text = choice(SURROGATES)
        return [text]

    def genInterestingValues(self):
        interesting = choice(INTERESTING)
        return [interesting]

    def genBufferObject(self):
        text = choice(BUFFER_OBJECTS)
        return [text]

    def genAsciiString(self):
        return self._genUnicode(self.ascii_generator)

    def genFloat(self):
        int_part = self.float_int_generator.createValue()
        float_part = self.float_float_generator.createValue()
        return ["%s.%s" % (int_part, float_part)]

    def genExistingFilename(self):
        filename = choice(self.filenames)
        return ["'%s'" % filename]

    def genErrback(self):
        return ["%s" % ERRBACK_NAME]

    def genOpenFile(self):
        filename = choice(self.filenames)
        if RUNNING_PYTHON3:
            instr = "open('%s')" % filename
        else:
            instr = "open(u'%s')" % filename
        return [instr]

    def genException(self):
        return ["Exception('pouet')"]

    def _genList(self, open_text, close_text, empty, is_dict=False):
        # 90% of the time generate values of the same type
        same_type = randint(0, 9) != 0
        nb_item = randint(0, 9)
        if not nb_item:
            return [empty]
        items = []
        if same_type:
            if is_dict:
                key_callback = choice(self.hashable_argument_generators)
            value_callback = choice(self.simple_argument_generators)
            for index in xrange(nb_item):
                if is_dict:
                    item = self.createDictItem(key_callback, value_callback)
                else:
                    item = value_callback()
                items.append(item)
        else:
            for index in xrange(nb_item):
                if is_dict:
                    item = self.createDictItem()
                else:
                    item = self.createArgument()
                items.append(item)
        lines = []
        for item_index, item_lines in enumerate(items):
            if item_index:
                lines[-1] += ","
                for index, line in enumerate(item_lines):
                    # Add ' ' suffix to all lines
                    item_lines[index] = " " + line
            lines.extend(item_lines)
        if nb_item == 1 and empty == "tuple()":
            lines[-1] += ","
        lines[0] = open_text + lines[0]
        lines[-1] += close_text
        return lines

    def createDictItem(self, key_callback=None, value_callback=None):
        if key_callback:
            key = key_callback()
        else:
            key = self.createHashableArgument()
        if value_callback:
            value = value_callback()
        else:
            value = self.createArgument()
        key[-1] += ": " + value[0]
        key.extend(value[1:])
        return key

    def genList(self):
        return self._genList("[", "]", "[]")

    def genTuple(self):
        return self._genList("(", ")", "tuple()")

    def genDict(self):
        return self._genList("{", "}", "{}", True)


def parseArguments(arguments, defaults):
    for arg in arguments.split(","):
        arg = arg.strip(" \n[]")
        if not arg:
            continue
        if "=" in arg:
            arg, value = arg.split("=", 1)
            defaults[arg] = value
        yield arg


def parsePrototype(doc):
    r"""
    >>> parsePrototype("test([x])")
    ((), None, ('x',), {})
    >>> parsePrototype('dump(obj, file, protocol=0)')
    (('obj', 'file'), None, ('protocol',), {'protocol': '0'})
    >>> parsePrototype('setitimer(which, seconds[, interval])')
    (('which', 'seconds'), None, ('interval',), {})
    >>> parsePrototype("decompress(string[, wbits[, bufsize]])")
    (('string',), None, ('wbits', 'bufsize'), {})
    >>> parsePrototype("decompress(string,\nwbits)")
    (('string', 'wbits'), None, (), {})
    >>> parsePrototype("get_referents(*objs)")
    ((), '*objs', (), {})
    >>> parsePrototype("nothing")
    """
    if not doc:
        return None
    if not isinstance(doc, string_types):
        return None
    doc = doc.strip()
    match = PROTOTYPE_REGEX.match(doc)
    if not match:
        return None
    arguments = match.group(1)
    if arguments == "...":
        return None
    defaults = {}
    vararg = None
    varkw = tuple()
    if "[" in arguments:
        arguments, varkw = arguments.split("[", 1)
        arguments = tuple(parseArguments(arguments, defaults))
        varkw = tuple(parseArguments(varkw, defaults))
    else:
        arguments = tuple(parseArguments(arguments, defaults))

    # Argument with default value? => varkw
    move = None
    for index in xrange(len(arguments) - 1, -1, -1):
        arg = arguments[index]
        if arg not in defaults:
            break
        move = index
    if move is not None:
        varkw = arguments[move:] + varkw
        arguments = arguments[:move]

    if arguments and arguments[-1].startswith("*"):
        vararg = arguments[-1]
        arguments = arguments[:-1]
    return arguments, vararg, varkw, defaults


def parseDocumentation(doc, max_var_arg):
    """
    Arguments:
     - doc: documentation string
     - max_var_arg: maximum number of arguments for variable argument,
       eg. test(*args).
    """
    prototype = parsePrototype(doc)
    if not prototype:
        return None

    args, varargs, varkw, defaults = prototype
    min_arg = len(args)
    max_arg = min_arg + len(varkw)
    if varargs:
        max_arg += max_var_arg
    return min_arg, max_arg


if __name__ == "__main__":
    Fuzzer().main()
