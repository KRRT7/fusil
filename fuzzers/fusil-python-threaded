#!/usr/bin/env python
"""
Generate Python source code: random function calls with random arguments.
Use "python" command line program.

Interesting modules: all modules written in C or having some code written
in C, see Modules/*.c in Python source code.
"""

import builtins
import datetime
import inspect
import pkgutil
import random
import re
import resource
import sys
import time
import warnings
from optparse import OptionGroup
from os.path import exists as path_exists, isabs, sep as path_sep
from random import choice, randint, sample
from types import BuiltinFunctionType, FunctionType, ModuleType

from ptrace.os_tools import RUNNING_PYTHON3

from fusil.application import Application
from fusil.bytes_generator import BytesGenerator
from fusil.process.create import CreateProcess
from fusil.process.stdout import WatchStdout
from fusil.process.watch import WatchProcess
from fusil.project_agent import ProjectAgent
from fusil.six import string_types, text_type
from fusil.unicode_generator import (
    ASCII8,
    DECIMAL_DIGITS,
    LETTERS,
    PRINTABLE_ASCII,
    UNICODE_65535,
    IntegerGenerator,
    IntegerRangeGenerator,
    UnicodeGenerator,
    UnixPathGenerator,
    UnsignedGenerator,
)
from fusil.write_code import WriteCode

if not RUNNING_PYTHON3:
    from sys import getfilesystemencoding


# Fuzzer options
IGNORE_TIMEOUT = True
IGNORE_CPU = True
SHOW_STDOUT = False
DEBUG = False

xrange = range

print(sys.version)

# Constants
TIMEOUT = 150.0
PYTHON = sys.executable
FILENAMES = "/etc/machine-id,/bin/sh"
PARSE_PROTOTYPE = True
PROTOTYPE_REGEX = re.compile(r"[A-Za-z]+[A-Za-z_0-9]*\(([^)]*)\)", re.MULTILINE)

MODULE_BLACKLIST = {
    "logging",
    "pydoc",
    "getpass",
    "commands",
    "subprocess",
    "antigravity",
    "compileall",
    "user",
    "this",
    "_testcapi",
    "_testlimitedcapi",
    "_testinternalcapi",
    "test",
    "ctypes",
    "_ctypes",
    "fusil",
    "ptrace",
    "pip",
    "setuptools",
    "distutils",
    "_signal",
    "signal",
    "__builtin__",
    "xxlimited",
    "xxlimited_35",
    "xxsubtype",
    "tkinter",
}

CTYPES = {
    "PyObj_FromPtr",
    "string_at",
    "wstring_at",
    "call_function",
    "call_cdeclfunction",
    "Py_INCREF",
    "Py_DECREF",
    "dlsym",
    "dlclose",
    "_string_at_addr",
    "_wstring_at_addr",
    "dlopen",
}

SOCKET = {
    "gethostbyname",
    "gethostbyname_ex",
    "gethostbyaddr",
    "getnameinfo",
    "getaddrinfo",
    "socket",
    "SocketType",
}

POSIX = {
    "_exit",
    "abort",
    "read",
    "ftruncate",
    "rmdir",
    "unlink",
    "kill",
    "killpg",
    "fork",
    "forkpty",
    "system",
    "popen",
    "popen2",
    "popen3",
    "popen4",
    "spawnl",
    "spawnle",
    "spawnlp",
    "spawnlpe",
    "spawnv",
    "spawnve",
    "spawnvp",
    "spawnvpe",
    "execl",
    "execle",
    "execlp",
    "execlpe",
    "execv",
    "execve",
    "execvp",
    "execvpe",
    "wait",
    "wait3",
    "waitpid",
    "tcsetpgrp",
    "closerange",
}

BUILTINS = {"pow", "round"}

# Functions and methods blacklist. Format:
#   module name => function and class names
# and
#    module name:class name => method names
BLACKLIST = {
    # sys tracing that will cause an error in fuzzing
    "sys": {"settrace", "setprofile"},
    # Dangerous module: ctypes
    "ctypes": CTYPES,
    "_ctypes": CTYPES,
    # Eat a lot of CPU with large arguments
    "itertools": {"tee"},
    "math": {"factorial", "perm", "comb"},
    "operator": {
        "pow",
        "__pow__",
        "ipow",
        "__ipow__",
        "mul",
        "rmul",
        "imul",
        "__mul__",
        "__rmul__",
        "__imul__",
        "repeat",
        "__repeat__",
    },
    "__builtin__": BUILTINS,
    "builtins": BUILTINS,
    # Don't raise SystemError
    "_builtin__:set": {"test_c_api"},
    "builtins:set": {"test_c_api"},
    # Sleep
    "time": {"sleep", "pthread_getcpuclockid"},
    "select": {"epoll", "poll", "select"},
    "signal": {"pause", "alarm", "setitimer", "pthread_kill"},
    "_signal": {
        "pause",
        "alarm",
        "setitimer",
        "pthread_kill",
        "sigwait",
        "sigwaitinfo",
        "sigtimedwait",
    },
    "_socket": SOCKET,
    "socket": SOCKET,
    "posix": POSIX,
    "os": POSIX,
    "_fileio:_FileIO": {"read", "readall"},
    # timeout
    "multiprocessing": {"Pool"},
    "_multiprocessing:SemLock": {"acquire"},
    "_multiprocessing:Connection": {"recv", "recv_bytes", "poll"},
    "_tkinter": {"dooneevent", "create", "mainloop"},
    "termios": {"tcflow"},
    "dl": {"open"},
    "pydoc": {"serve", "doc", "apropos"},
    # listen to a socket and wait for requests
    "BaseHTTPServer": {"test"},
    "CGIHTTPServer": {"test"},
    "SimpleHTTPServer": {"test"},
    "pprint": {"_perfcheck"},  # timeout (unlimited loop?)
    "tabnanny": {"check"},  # python 2.5.2 implementation is just slow
    # create child process
    "popen2": {"popen2", "popen3", "popen4", "Popen3", "Popen4"},
    "pty": {"fork", "spawn"},
    "platform": {"_syscmd_uname"},
    # avoid false positive with pattern on stdout
    "logging": {"warning", "error", "fatal", "critical"},
    "formatter": {"test"},
    # Create huge integer, very long string or list
    "fpformat": {"fix"},
    # remove directory
    "shutil": {"copytree", "rmtree"},
    # open a network connection (timeout)
    # FIXME: only blacklist the blocking methods, not the whole class?
    "imaplib": {"IMAP4", "IMAP4_stream"},
    "telnetlib": {"Telnet"},
    "nntplib": {"NNTP"},
    "smtplib": {"SMTP", "SMTP_SSL"},
    # open a network connection (timeout),
    # the constructor opens directly a connection
    "poplib": {"POP3", "POP3_SSL"},
    "ftplib": {"FTP", "FTP_TLS"},
    # set resource limit, may stop the process:
    # setrlimit(RLIMIT_CPU, (0, 0)) kills the process with a SIGKILL signal
    "resource": {"setrlimit"},
    "xmllib": {"test"},  # timeout
    "urllib2": {"randombytes"},  # unlimited loop
    "py_compile": {"compile"},
    "runpy": {"run_path"},
    "faulthandler": {
        "_fatal_error",
        "_read_null",
        "_sigabrt",
        "_sigbus",
        "_sigfpe",
        "_sigill",
        "_sigsegv",
        "_stack_overflow",
        "_fatal_error_c_thread",
    },
    "_thread": {
        "LockType",
        "RLock",
        "interrupt_main",
        "exit",
        "lock",
        "allocate_lock",
        "allocate",
        "_exit_thread",
    },
    "_queue:SimpleQueue": {"get"},
    "queue:LifoQueue": {"get"},
    "queue:PriorityQueue": {"get"},
    "queue:Queue": {"get"},
    "queue:SimpleQueue": {"get"},
    "queue:_PySimpleQueue": {"get"},
    "gc": {"get_objects"},
    # TODO: blacklist distutils/spawn.py (35): spawn
    # TODO: blacklist distutils/spawn.py (121): _spawn_posix
}

OBJECT_BLACKLIST = {
    "_PyRLock",
    "BoundedSemaphore",
    "LockType",
    "Lock",
    "RLock",
    "Semaphore",
}

METHOD_BLACKLIST = {
    "__class__",
    "__enter__",  # Damn locks
    "__imul__",
    "__ipow__",
    "__mul__",
    "__pow__",
    "__rmul__",
    "_acquire_lock",
    "_acquire_restore",
    "_handle_request_noblock",
    "_randbelow",
    "_randbelow_with_getrandbits",
    "_read",
    "_run_once",
    "_serve",
    "_shutdown",
    "accept",
    "acquire",
    "acquire_lock",
    "cmdloop",
    "copyfileobj",
    "get",  # Damn queues
    "get_request",
    "handle_request",
    "handle_request_noblock",
    "prefix",
    "raise_signal",
    "run_forever",
    "select",
    "serve_forever",
    "shutdown",
    "sleep",
    "test",
    "tri",
    "tril_indices",
    "wait",
    "zfill",
}

# Currently we have to import all C modules before running the fuzzer.
# TODO: figure out why and fix it properly.
for name in sys.stdlib_module_names:
    if name not in MODULE_BLACKLIST and "test" not in name:
        try:
            sys.modules[name] = __import__(name)
        except ImportError as e:
            print("Failed to import module %s\n" % name, e)

if DEBUG:
    NB_CALL = 5
    NB_METHOD = 1
    NB_CLASS = 5
else:
    NB_CALL = 250
    NB_METHOD = 15
    NB_CLASS = 50
MAX_ARG = 6
MAX_VAR_ARG = 5

EXCLUDE_EXCEPTIONS = True
EXCEPTION_NAMES = {
    cls.__name__ for cls in builtins.__dict__.values()
    if isinstance(cls, type) and issubclass(cls, Exception)
}


if RUNNING_PYTHON3:
    SURROGATES = (
        '"\\x00"',
        '"\\x00"',
        '"\\x00"',
        '"\\x00"',
        '"\\uDC80"',
        '"\\uDC80"',
        '"\\U0010FFFF"',
        '"\\U0010FFFF"',
        '"\\udbff\\udfff"',
    )

    BUFFER_OBJECTS = (
        'bytearray(b"abc\\xe9\\xff")',
        'memoryview(b"abc\\xe9\\xff")',
        'memoryview(bytearray(b"abc\\xe9\\xff"))',
    )
else:
    SURROGATES = (
        'u"\\uDC80"',
        'u"\\uDC80"',
        'u"\\U0010FFFF"',
        'u"\\udbff\\udfff"',
    )

    BUFFER_OBJECTS = ('buffer("abc\\xe9\\xff")',)

INTERESTING = (
    # Large integer boundaries
    "sys.maxsize",  # Maximum integer size for current platform
    "sys.maxsize - 1",  # One below maximum integer size
    "sys.maxsize + 1",  # One above maximum integer size (overflow test)
    "-sys.maxsize",  # Negative maximum integer boundary
    "2 ** 63 - 1",  # 64-bit integer boundary (signed max for 64-bit)
    "-2 ** 63",  # 64-bit integer boundary (signed min for 64-bit)
    "2 ** 31 - 1",  # 32-bit integer boundary (signed max for 32-bit)
    "-2 ** 31",  # 32-bit integer boundary (signed min for 32-bit)
    # Large powers and exponential values
    "10 ** (sys.int_info.default_max_str_digits + 1)",  # Overflow of typical max digit handling
    "10 ** 100",  # Extremely large integer to test overflow and precision
    "-10 ** (sys.int_info.default_max_str_digits)",  # Large negative integer boundary
    "10 ** (sys.int_info.default_max_str_digits + 2)",  # Further max digit overflow test
    # Floating-point boundaries and edge cases
    'float("nan")',  # NaN, tests handling of undefined floats
    'float("inf")',  # Positive infinity
    'float("-inf")',  # Negative infinity
    "sys.float_info.epsilon",  # Smallest positive float greater than zero
    "sys.float_info.max",  # Maximum representable float
    "sys.float_info.min",  # Minimum positive float
    "-sys.float_info.max",  # Negative maximum float
    "-sys.float_info.epsilon",  # Negative epsilon (smallest magnitude negative float)
    "sys.float_info.min / 2",  # Value close to underflow boundary
    "-sys.float_info.min / 2",  # Negative value close to underflow boundary
    'float("0.0000001")',  # Very small float, near zero
    '-float("0.0000001")',  # Very small negative float, near zero
    # Complex numbers with extreme values
    "complex(sys.maxsize, sys.maxsize)",  # Large complex number with large real and imaginary parts
    'complex(float("inf"), float("nan"))',  # Complex with infinity and NaN
    "complex(sys.float_info.max, sys.float_info.epsilon)",  # Mix of large and tiny parts in complex
    "1j",  # Small complex number with imaginary unit
    "-1j",  # Negative small complex number with imaginary unit
    # Unicode and string boundary tests
    "chr(0)",  # Null character
    "chr(127)",  # Edge of ASCII range
    "chr(255)",  # Edge of extended ASCII range
    "chr(0x10FFFF)",  # Maximum Unicode code point
    r'"\uDC80"',  # Unpaired surrogate, tests encoding robustness
    '"𝒜"',  # Surrogate pair in UTF-16
    r'"\x00" * 10',  # Null byte sequence
    '"A" * (2 ** 16)',  # Large string boundary (typical buffer size)
    '"💻" * 2**10',  # Large string with multibyte Unicode characters
    # Boolean and None values
    "True",  # Basic boolean value
    "False",  # Basic boolean value
    "None",  # None, tests for null handling
    # Pathological data structures
    "[]",  # Empty list
    "[[]]",  # Nested empty list
    "[[[]]]",  # Deeply nested empty list
    "{0: {0: {0: {}}}}",  # Deeply nested dictionary
    '[(None, 1, "a") for _ in range(2**10)]',  # Large list with mixed types
    "[[1] * 10] * 10",  # Nested lists with shared references
    'bytearray(b"")',  # Empty byte array
    'bytearray(b"A" * 2**10)',  # Moderately large byte array
    # Bytes and encoded data
    "bytes(10 ** 5)",  # Large empty bytes sequence
    "bytes(range(256))",  # Full byte range, all possible byte values
    r'b"\x00" * (2**16)',  # Maximum byte array handling with null bytes
    'memoryview(b"A" * 2**8)',  # Memory view around a moderately large byte array
    # Regular expressions and raw strings
    'r"^(?:a|aa)*$"',  # Complex regex pattern
    r'r"\A[\w-]+\Z"',  # Simple regex pattern
    r'r"\d{1,100}"',  # Large quantifier regex pattern
    # Lambda and object instances
    "lambda: None",  # Simple lambda function (tests function call handling)
    "(lambda x: sys.maxsize)",  # Lambda with boundary value as output
    "object()",  # Base object with minimal attributes
    "frozenset({sys.maxsize, -sys.maxsize})",  # Immutable set with boundary values
    # Other encoding and integer tests
    '"A" * (2**10)',  # Large simple string
    "complex(-10 ** 10, 10 ** 10)",  # Complex number with extreme real and imaginary values
    "(sys.maxunicode + 1,)",  # Beyond max Unicode
)


class ListAllModules:
    def __init__(self, logger, only_c, site_package, blacklist):
        self.logger = logger
        self.only_c = only_c
        self.site_package = site_package
        self.blacklist = blacklist
        self.names = set(sys.builtin_module_names) - {"__main__"}

    def matchModule(self, is_package, name, filename):
        if filename is not None and not self.filter_filename(filename):
            return False
        if not self.only_c:
            return True
        if is_package:
            return False
        if any(
            filename.endswith(ext)
            for ext in (".py", ".pyc", ".pyo")
            if filename is not None
        ):
            return False
        return True

    def filter_filename(self, filename):
        if not self.site_package:
            if "site-packages" in filename.split(path_sep):
                return False
        if name in self.blacklist:
            return False
        return True

    def walk_packages(self, path=None, prefix="", onerror=None):
        def seen(p, m={}):
            if p in m:
                return True
            m[p] = True

        for info in pkgutil.iter_modules(path, prefix):
            path = package = None
            if info.name in sys.modules:
                path = getattr(sys.modules[info.name], "__path__", None)
                package = getattr(sys.modules[info.name], "__package__", None)
            if (
                "test" in info.name
                or "pip" in info.name
                or "logging" in info.name
                or "pydoc" in info.name
                or "tkinter" in info.name
                or (path is not None and any("site-packages" in p for p in path))
                or (package is not None and "pip" in package)
            ):
                print("SKIPPED", info, file=sys.stderr)
                continue
            yield info

            if info.ispkg:
                try:
                    __import__(info.name)
                except ImportError:
                    if onerror is not None:
                        onerror(info.name)
                except Exception:
                    if onerror is not None:
                        onerror(info.name)
                    else:
                        raise
                else:
                    if info.name in sys.modules:
                        path = getattr(sys.modules[info.name], "__path__", None) or []
                        # don't traverse path items we've seen before
                        path = [p for p in path if not seen(p)]
                        yield from self.walk_packages(path, info.name + ".", onerror)

    def search_modules(self, path, prefix):
        if path is not None and not self.site_package:
            path = [name for name in path if self.filter_filename(name)]
            if not path:
                return
        try:
            for loader, name, is_package in self.walk_packages(
                None, onerror=lambda x: None
            ):
                if name.endswith("_d"):
                    # Ignore Debian debug modules
                    # (e.g. ignore "_bisect_d", the real module is "_bisect)
                    continue
                if (
                    name in self.blacklist
                    or prefix in self.blacklist
                    or prefix.split(".")[0] in self.blacklist
                    or name.split(".")[0] in self.blacklist
                    or "test" in name
                    or "idlelib" in name
                    or "pydoc" in name
                    or "logging" in name
                ):
                    # Ignore the module and all of its submodules
                    self.logger.error(f"IGNORED {prefix}:{name}")
                    continue
                fullname = prefix + name
                if self.only_c:
                    module = None
                    if fullname in sys.modules:
                        module = sys.modules[fullname]
                    elif name in sys.modules:
                        module = sys.modules[name]
                    elif name.split(".")[0] in sys.modules:
                        module = sys.modules[name.split(".")[0]]
                    elif prefix in sys.modules:
                        module = sys.modules[prefix]
                    elif prefix.split(".")[0] in sys.modules:
                        module = sys.modules[prefix.split(".")[0]]
                    if module and hasattr(module, "__file__"):
                        if module.__file__.endswith(("py", "pyo", "pyc", "pyw")):
                            self.logger.error(f"SKIP PYTHON MODULE {fullname}")
                            continue
                self.logger.error(f"ADDING {fullname}: {prefix}+{name}")
                self.names.add(fullname)
        except:
            raise

    def search(self):
        self.search_modules(None, "")
        return self.names


class Fuzzer(Application):
    NAME = "python"

    def createFuzzerOptions(self, parser):
        options = OptionGroup(parser, "Python fuzzer")
        options.add_option(
            "--modules",
            help="Tested Python module names separated by commas (default: test all modules)",
            type="str",
            default="*",
        )
        options.add_option(
            "--blacklist",
            help='Module blacklist separated by commas (eg. "_lsprof,_json")',
            type="str",
        )
        options.add_option(
            "--test-private",
            help="Test private methods (default: skip privates methods)",
            action="store_true",
        )
        options.add_option(
            "--timeout",
            help="Timeout in seconds (default: %.1f)" % TIMEOUT,
            type="float",
            default=TIMEOUT,
        )
        options.add_option(
            "--filenames",
            help="Names separated by commas of readable files (default: %s)"
            % FILENAMES,
            type="str",
            default=FILENAMES,
        )
        options.add_option(
            "--python",
            help="Python executable program path (default: %s)" % PYTHON,
            type="str",
            default=PYTHON,
        )
        options.add_option(
            "--only-c",
            help="Only search for modules written in C (default: search all module)",
            action="store_true",
        )
        options.add_option(
            "--no-site-packages",
            help="Don't search modules in site-packages directory",
            action="store_true",
        )
        return options

    def setupProject(self):
        project = self.project

        project.error(f"Start time: {time.asctime()}")
        project.error("Use python interpreter: %s" % self.options.python)
        version = " -- ".join(line.strip() for line in sys.version.splitlines())
        project.error("Python version: %s" % version)
        PythonSource(project, self.options)
        process = PythonProcess(
            project,
            [self.options.python, "-u", "<source.py>"],
            timeout=self.options.timeout,
        )
        process.max_memory = 4000 * 1024 * 1024 * 1024 * 1024
        options = {"exitcode_score": 0}
        if IGNORE_TIMEOUT:
            options["timeout_score"] = 0
        watch = WatchProcess(process, **options)
        if watch.cpu and IGNORE_CPU:
            watch.cpu.max_score = 0

        stdout = WatchStdout(process)
        stdout.max_nb_line = None

        # Disable dummy error messages
        stdout.words = {
            "oops": 0.30,
            "bug": 0.10,
            "fatal": 0.1,
            # "assert": 0.025,
            "assertion": 1.0,
            "critical": 1.0,
            "panic": 1.0,
            "glibc detected": 1.0,
            "segfault": 1.0,
            "segmentation fault": 1.0,
            "SystemError": 1.0,
            "AddressSanitizer": 1.0,
        }

        stdout.kill_words = {"MemoryError", "mimalloc"}

        # CPython critical messages
        stdout.addRegex("^XXX undetected error", 1.0)
        stdout.addRegex("Fatal Python error", 1.0)
        # Match "Cannot allocate memory"?

        # PyPy messages
        stdout.addRegex("Fatal RPython error", 1.0)

        if SHOW_STDOUT or DEBUG:
            stdout.show_matching = True
            stdout.show_not_matching = True

        # avoid matching on "assert" keyword
        stdout.ignoreRegex(r"ast\.Assert()")

        # PyPy interact prompt
        # avoid false positive on "# assert did not crash"
        stdout.ignoreRegex(r"^And now for something completely different:")

        # Hide Python warnings on import
        warnings.simplefilter("ignore")

    def exit(self, keep_log=True):
        super().exit(keep_log=keep_log)
        self.error(print_running_time())


ERRBACK_NAME = "errback"

METHODS_NB_ARG = {
    "__abs__": 0,
    "__add__": 1,
    "__aenter__": 0,
    "__aexit__": 0,
    "__aiter__": 0,
    "__and__": 1,
    "__anext__": 0,
    "__await__": 0,
    "__bool__": 0,
    "__buffer__": 1,
    "__bytes__": 0,
    "__ceil__": 0,
    "__class_getitem__": 1,
    "__complex__": 0,
    "__contains__": 1,
    "__copy__": 0,
    "__deepcopy__": 1,
    "__delattr__": 1,
    "__delete__": 1,
    "__delitem__": 1,
    "__dir__": 0,
    "__div__": 1,
    "__divmod__": 1,
    "__enter__": 0,
    "__eq__": 1,
    "__exit__": 3,
    "__float__": 0,
    "__floor__": 1,
    "__floordiv__": 0,
    "__format__": 1,
    "__fspath__": 0,
    "__ge__": 1,
    "__get__": 2,
    "__getattr__": 1,
    "__getattribute__": 1,
    "__getitem__": 1,
    "__getnewargs__": 0,
    "__getnewargs_ex__": 0,
    "__getslice__": 2,
    "__getstate__": 0,
    "__gt__": 1,
    "__hash__": 0,
    "__iadd__": 1,
    "__iand__": 1,
    "__idiv__": 1,
    "__ifloordiv__": 0,
    "__ilshift__": 1,
    "__imatmul__": 1,
    "__imod__": 1,
    "__index__": 0,
    "__init_subclass__": 1,
    "__instancecheck__": 1,
    "__int__": 0,
    "__invert__": 0,
    "__ior__": 1,
    "__irshift__": 1,
    "__isub__": 1,
    "__iter__": 0,
    "__itruediv__": 1,
    "__ixor__": 1,
    "__le__": 1,
    "__len__": 0,
    "__length_hint__": 0,
    "__lshift__": 1,
    "__lt__": 1,
    "__matmul__": 1,
    "__missing__": 1,
    "__mod__": 1,
    "__mro_entries__": 0,
    "__ne__": 1,
    "__neg__": 0,
    "__new__": 3,
    "__next__": 1,
    "__or__": 1,
    "__pos__": 0,
    "__post_init__": 2,
    "__prepare__": 0,
    "__radd__": 1,
    "__rand__": 1,
    "__rdivmod__": 1,
    "__reduce__": 0,
    "__reduce_ex__": (0, 1),
    "__release_buffer__": 1,
    "__replace__": 1,
    "__repr__": 0,
    "__reversed__": 0,
    "__rfloordiv__": 0,
    "__rlshift__": 1,
    "__rmatmul__": 1,
    "__rmod__": 1,
    "__ror__": 1,
    "__round__": 0,
    "__rrshift__": 1,
    "__rshift__": 1,
    "__rsub__": 1,
    "__rtruediv__": 1,
    "__rxor__": 1,
    "__set__": 2,
    "__set_name__": 2,
    "__setattr__": 2,
    "__setitem__": 2,
    "__setstate__": 1,
    "__sizeof__": 0,
    "__str__": 0,
    "__sub__": 1,
    "__subclasscheck__": 1,
    "__subclasshook__": 1,
    "__truediv__": 1,
    "__trunc__": 0,
    "__xor__": 1,
    "abs": 1,
    "add": 1,
    "all": 1,
    "any": 1,
    "append": 1,
    "ascii": 1,
    "bin": 1,
    "callable": 1,
    "chr": 1,
    "clear": 0,
    "close": 0,
    "compile": (3, 6),
    "decode": 0,
    "delattr": 2,
    "dir": 1,
    "divmod": 2,
    "encode": 0,
    "eval": (1, 3),
    "exec": 3,
    "format": (1, 2),
    "get": (1, 2),
    "getattr": (2, 3),
    "getvalue": 0,
    "hasattr": 2,
    "hash": 1,
    "hex": 1,
    "isinstance": 2,
    "issubclass": 2,
    "items": 0,
    "iter": (1, 2),
    "join": 1,
    "keys": 0,
    "len": 1,
    "match": 1,
    "max": (1, 4),
    "min": (1, 4),
    "next": (1, 2),
    "oct": 1,
    "open": (1, 8),
    "ord": 1,
    "pop": (0, 1),
    "read": (0, 1),
    "replace": 2,
    "repr": 1,
    "round": (1, 2),
    "setattr": 3,
    "sort": 0,
    "sorted": 1,
    "split": 1,
    "strip": (0, 1),
    "sum": (1, 2),
    "update": 1,
    "values": 0,
    "write": 1,
}

CLASS_NB_ARG = {
    "bool": (1, 1),
    "bytearray": (0, 3),
    "bytes": (0, 3),
    "classmethod": (1, 1),
    "complex": (0, 2),
    "dict": (0, 1),
    "enumerate": (1, 2),
    "filter": (2, 2),
    "float": (1, 1),
    "frozenset": (0, 1),
    "int": (0, 2),
    "list": (0, 1),
    "map": (2, 5),
    "memoryview": (1, 1),
    "object": (0, 0),
    "property": (1, 4),
    "range": (1, 3),
    "reversed": (1, 1),
    "set": (1, 1),
    "slice": (1, 3),
    "staticmethod": (1, 1),
    "str": (0, 3),
    "super": (1, 2),
    "tuple": (0, 1),
    "type": (0, 3),
    "zip": (1, 3),
}

class PythonFuzzerError(Exception):
    pass


class PythonSource(ProjectAgent):
    def __init__(self, project, options):
        ProjectAgent.__init__(self, project, "python_source")
        self.options = options
        if self.options.modules != "*":
            self.modules = set()
            for module in self.options.modules.split(","):
                module = module.strip()
                if not len(module):
                    continue
                self.modules.add(module)
        else:
            self.error("Search all Python modules...")
            self.modules = ListAllModules(
                self,
                self.options.only_c,
                not self.options.no_site_packages,
                MODULE_BLACKLIST,
            ).search()
        blacklist = self.options.blacklist
        if blacklist:
            blacklist = set(blacklist.split(","))
            removed = self.modules & blacklist
            self.error("Blacklist modules: %s" % removed)
            self.modules = list(self.modules - blacklist)
        self.modules = list(self.modules)
        self.modules.sort()
        self.error("Found %s Python modules" % len(self.modules))
        for name in self.modules:
            self.info("Python module: %s" % name)

        self.filenames = self.options.filenames
        if not RUNNING_PYTHON3:
            encoding = getfilesystemencoding()
            self.filenames = text_type(self.filenames, encoding)
        self.filenames = self.filenames.split(",")
        for filename in self.filenames:
            if not isabs(filename):
                raise ValueError(
                    "Filename %r is not an absolute path! Fix the --filenames option"
                    % filename
                )
            if not path_exists(filename):
                raise ValueError(
                    "File doesn't exist: %s! Use different --filenames option"
                    % filename
                )
        project.error("Use filenames: %s" % ", ".join(self.filenames))
        self.error(print_running_time())

    def loadModule(self, module_name):
        self.module_name = module_name
        self.debug("Import %s" % self.module_name)
        self.module = __import__(self.module_name)
        for name in self.module_name.split(".")[1:]:
            self.module = getattr(self.module, name)
        try:
            self.warning("Module filename: %s" % self.module.__file__)
        except AttributeError:
            pass
        self.write = WritePythonCode(self, self.filename, self.module,
                                     self.module_name, threads=True,
                                     _async=True)

    def on_session_start(self):
        self.filename = self.session().createFilename("source.py")

        # copy sys.modules
        old_sys_modules = sys.modules.copy()

        while self.modules:
            name = choice(self.modules)
            try:
                self.loadModule(name)
                break
            except BaseException as err:
                self.error(
                    "Unable to load module %s: [%s] %s"
                    % (name, err.__class__.__name__, err)
                )
                self.modules.remove(name)
        if not self.modules:
            self.error("There is no more modules!")
            self.send("project_stop")
            return
        self.error("Test module %s" % name)
        self.error(print_running_time())
        self.send("session_rename", name)

        self.write.writeSource()
        self.send("python_source", self.filename)

        # unload new modules
        sys.modules.clear()
        sys.modules.update(old_sys_modules)


class PythonProcess(CreateProcess):
    def on_python_source(self, filename):
        self.cmdline.arguments[-1] = filename
        self.createProcess()


# >'<, >"<, >\<
ESCAPE_CHARACTERS = "'" + '"' + "\\"


def formatCharacter(char):
    if char in ESCAPE_CHARACTERS:
        # >\"<
        return "\\" + char
    code = ord(char)
    if 32 <= code <= 126:
        # >a<
        return char
    elif code <= 255:
        # >\xEF<
        return "\\x%02X" % code
    elif code <= 65535:
        # >\u0101<
        return "\\u%04X" % code
    else:
        # >\U00010FA3<
        return "\\U%08X" % code


def escapeUnicode(text):
    return "".join(formatCharacter(char) for char in text)



mangle_obj = """def mangle_obj(instance, method, *args):
    print(f'Mangling {instance} with MagicMock()s, leaving {method} intact.', file=stderr)
    real_instance_dict = instance.__dict__.copy()
    real_class_dict = instance.__class__.__dict__.copy()

    func = getattr(instance, method)

    try:
        for key, value in instance.__dict__.items():
            if key.startswith('__') or key == func.__name__:
                continue
            try:
                setattr(instance, key, MagicMock())
            except Exception:
                pass

        for key, value in instance.__class__.__dict__.items():
            if key.startswith('__') or key == func.__name__:
                continue
            try:
                setattr(instance.__class__, key, MagicMock())
            except Exception:
                pass
        print(f'Calling {instance}.{method}...', file=stderr)
        func(*args)

    except Exception as err:
        try:
            errmsg = repr(err)
        except ValueError as e:
            errmsg = repr(e)
        errmsg = errmsg.encode('ASCII', 'replace')
        print ('[%s] %s => %s: %s' % (instance, func.__name__, err.__class__.__name__, errmsg), file=stderr)

    finally:
        instance.__dict__.update(real_instance_dict)
        for key, value in real_class_dict.items():
            if key.startswith('__') or key == func.__name__:
                continue
            try:
                setattr(instance.__class__, key, value)
            except Exception:
                pass
"""

# The weird indentation is necessary because we write this in two levels
mangle_loop = """if hasattr(obj.__class__, '__dict__'):
        for key, attr in obj.__class__.__dict__.items():
            args = %s
            try:
                args = len(inspect.getfullargspec(attr).args)
            except Exception:
                pass
            if key.startswith('__'):
                continue
            try:
                mangle_obj(obj, key, (1,) * args)
            except Exception as err:
                print(err, file=stderr)
"""

from _collections import OrderedDict, deque
from collections import Counter
from decimal import Decimal
from queue import Queue

sequences = [Queue, deque, frozenset, list, set, str, tuple] 
bytes_ = [bytearray, bytes]
numbers = [Decimal, complex, float, int]
# dicts = [Counter, OrderedDict, dict]
dicts = [OrderedDict, dict]
bases = sequences + bytes_ + numbers + dicts + [object]
weird_names = [f"weird_{cls.__name__}" for cls in bases]
weird_instance_names = [f"{name}_empty" for name in weird_names]

for x in range(3):
    for cls in sequences:
        weird_instance_names.append(f"weird_{cls.__name__}_single")
        weird_instance_names.append(f"weird_{cls.__name__}_range")
        weird_instance_names.append(f"weird_{cls.__name__}_types")
        weird_instance_names.append(f"weird_{cls.__name__}_printable")
        weird_instance_names.append(f"weird_{cls.__name__}_special")
    for cls in bytes_:
        weird_instance_names.append(f"weird_{cls.__name__}_bytes")
    for cls in dicts:
        weird_instance_names.append(f"weird_{cls.__name__}_basic")
        weird_instance_names.append(f"weird_{cls.__name__}_tricky_strs")

for cls in numbers:    
    weird_instance_names.append(f"weird_{cls.__name__}_sys_maxsize")
    weird_instance_names.append(f"weird_{cls.__name__}_sys_maxsize_minus_one")
    weird_instance_names.append(f"weird_{cls.__name__}_sys_maxsize_plus_one")
    weird_instance_names.append(f"weird_{cls.__name__}_neg_sys_maxsize")
    weird_instance_names.append(f"weird_{cls.__name__}_2**63-1")
    weird_instance_names.append(f"weird_{cls.__name__}_2**63")
    weird_instance_names.append(f"weird_{cls.__name__}_2**63+1")
    weird_instance_names.append(f"weird_{cls.__name__}_-2**63+1")
    weird_instance_names.append(f"weird_{cls.__name__}_-2**63")
    weird_instance_names.append(f"weird_{cls.__name__}_-2**63-1")
    weird_instance_names.append(f"weird_{cls.__name__}_2**31-1")
    weird_instance_names.append(f"weird_{cls.__name__}_2**31")
    weird_instance_names.append(f"weird_{cls.__name__}_2**31+1")
    weird_instance_names.append(f"weird_{cls.__name__}_-2**31+1")
    weird_instance_names.append(f"weird_{cls.__name__}_-2**31")
    weird_instance_names.append(f"weird_{cls.__name__}_-2**31-1")
    if cls not in (float, complex):
        weird_instance_names.append(f"weird_{cls.__name__}_10**default_max_str_digits+1")

weird_classes = """
from _collections import OrderedDict, deque
from abc import ABCMeta
from collections import Counter
from decimal import Decimal
from queue import Queue
from random import randint
from string import printable

sequences = [Queue, deque, frozenset, list, set, str, tuple] 
bytes_ = [bytearray, bytes]
numbers = [Decimal, complex, float, int]
# dicts = [Counter, OrderedDict, dict]
dicts = [OrderedDict, dict]
bases = sequences + bytes_ + numbers + dicts + [object]

large_num = 2**64
class WeirdBase(ABCMeta):
  def __hash__(self):
    return randint(0, large_num)

  def __eq__(self, other):
    return False


weird_instances = dict()
weird_classes = dict()
for cls in bases:
    class weird_cls(cls, metaclass=WeirdBase):
        def add(self, *args, **kwargs):
            pass
        append = clear = close = write = sort = reversed = add 
        def encode(self, *args, **kwargs):
            return b""
        def decode(self, *args, **kwargs):
            return ""
        format = getvalue = join = read = replace = strip = rstrip = decode
        def get(self, *args, **kwargs):
            return self
        open = pop = update = get 
        def readlines(self, *args, **kwargs):
            return [""]
        rsplit = split = partition = rpartition = readlines
        def items(self):
            return {}.items()
        def keys(self):
            return {}.keys()
        def values(self):
            return {}.values()

    weird_cls.__name__ = f"weird_{cls.__name__}"
    weird_instances[f"weird_{cls.__name__}_empty"] = weird_cls()
    weird_classes[f"weird_{cls.__name__}"] = weird_cls

tricky_strs = (chr(0), chr(127), chr(255), chr(0x10FFFF), "𝒜","\\x00" * 10, "A" * (2 ** 16), "💻" * 2**10,)

for cls in sequences:
    weird_instances[f"weird_{cls.__name__}_single"] = weird_classes[f"weird_{cls.__name__}"]("a")
    weird_instances[f"weird_{cls.__name__}_range"] = weird_classes[f"weird_{cls.__name__}"](range(20))
    weird_instances[f"weird_{cls.__name__}_types"] = weird_classes[f"weird_{cls.__name__}"](bases)
    weird_instances[f"weird_{cls.__name__}_printable"] = weird_classes[f"weird_{cls.__name__}"](printable)
    weird_instances[f"weird_{cls.__name__}_special"] = weird_classes[f"weird_{cls.__name__}"](tricky_strs)
for cls in bytes_:
    weird_instances[f"weird_{cls.__name__}_bytes"] = weird_classes[f"weird_{cls.__name__}"](b"abcdefgh_" * 10)
for cls in numbers:    
    weird_instances[f"weird_{cls.__name__}_sys_maxsize"] = weird_classes[f"weird_{cls.__name__}"](sys.maxsize)
    weird_instances[f"weird_{cls.__name__}_sys_maxsize_minus_one"] = weird_classes[f"weird_{cls.__name__}"](sys.maxsize - 1)
    weird_instances[f"weird_{cls.__name__}_sys_maxsize_plus_one"] = weird_classes[f"weird_{cls.__name__}"](sys.maxsize + 1)
    weird_instances[f"weird_{cls.__name__}_neg_sys_maxsize"] = weird_classes[f"weird_{cls.__name__}"](-sys.maxsize)
    weird_instances[f"weird_{cls.__name__}_2**63-1"] = weird_classes[f"weird_{cls.__name__}"](2 ** 63 - 1)
    weird_instances[f"weird_{cls.__name__}_2**63"] = weird_classes[f"weird_{cls.__name__}"](2 ** 63)
    weird_instances[f"weird_{cls.__name__}_2**63+1"] = weird_classes[f"weird_{cls.__name__}"](2 ** 63 + 1)
    weird_instances[f"weird_{cls.__name__}_-2**63+1"] = weird_classes[f"weird_{cls.__name__}"](-2 ** 63 + 1)
    weird_instances[f"weird_{cls.__name__}_-2**63"] = weird_classes[f"weird_{cls.__name__}"](-2 ** 63)
    weird_instances[f"weird_{cls.__name__}_-2**63-1"] = weird_classes[f"weird_{cls.__name__}"](-2 ** 63 -1)
    weird_instances[f"weird_{cls.__name__}_2**31-1"] = weird_classes[f"weird_{cls.__name__}"](2 ** 31 - 1)
    weird_instances[f"weird_{cls.__name__}_2**31"] = weird_classes[f"weird_{cls.__name__}"](2 ** 31)
    weird_instances[f"weird_{cls.__name__}_2**31+1"] = weird_classes[f"weird_{cls.__name__}"](2 ** 31 + 1)
    weird_instances[f"weird_{cls.__name__}_-2**31+1"] = weird_classes[f"weird_{cls.__name__}"](-2 ** 31 + 1)
    weird_instances[f"weird_{cls.__name__}_-2**31"] = weird_classes[f"weird_{cls.__name__}"](-2 ** 31)
    weird_instances[f"weird_{cls.__name__}_-2**31-1"] = weird_classes[f"weird_{cls.__name__}"](-2 ** 31 - 1)
    if cls not in (float, complex):
        weird_instances[f"weird_{cls.__name__}_10**default_max_str_digits+1"] = weird_classes[f"weird_{cls.__name__}"](10 ** (sys.int_info.default_max_str_digits + 1))
for cls in dicts:
    weird_instances[f"weird_{cls.__name__}_basic"] = weird_classes[f"weird_{cls.__name__}"]({a: a for a in range(100)})
    weird_instances[f"weird_{cls.__name__}_tricky_strs"] = weird_classes[f"weird_{cls.__name__}"]({a: a for a in tricky_strs})

"""

tricky_typing = """
import abc
import builtins
import collections.abc
import itertools
import types
import typing
from functools import reduce
from operator import or_

abc_types = [cls for cls in abc.__dict__.values() if isinstance(cls, type)]
builtins_types = [cls for cls in builtins.__dict__.values() if isinstance(cls, type)]
collections_abc_types = [cls for cls in collections.abc.__dict__.values() if isinstance(cls, type)]
collections_types = [cls for cls in collections.__dict__.values() if isinstance(cls, type)]
itertools_types = [cls for cls in itertools.__dict__.values() if isinstance(cls, type)]
types_types = [cls for cls in types.__dict__.values() if isinstance(cls, type)]
typing_types = [cls for cls in typing.__dict__.values() if isinstance(cls, type)]

all_types = (abc_types + builtins_types + collections_abc_types + collections_types + itertools_types
             + types_types + typing_types)
all_types = [t for t in all_types if not issubclass(t, BaseException)]
big_union = reduce(or_, all_types, int)
"""

tricky_objects_names = [
    "TrickyDescriptor()",
    "TrickyMeta",
    "tricky_capsule",
    "tricky_cell",
    "tricky_classmethod",
    "tricky_classmethod_descriptor",
    "tricky_closure",
    "tricky_code",
    "tricky_dict",
    "tricky_frame",
    "tricky_function",
    # "tricky_generator",  # Triggers too many free-threading segfaults
    "tricky_genericalias",
    "tricky_instance",
    "tricky_lambda",
    "tricky_list",
    "tricky_mappingproxy",
    "tricky_module",
    "tricky_module2",
    "tricky_property",
    "tricky_simplenamespace",
    "tricky_staticmethod",
    "tricky_traceback",
]

tricky_objects = """
import types
import inspect
import itertools
tricky_cell = types.CellType(None)
tricky_simplenamespace = types.SimpleNamespace(dummy=None, cell=tricky_cell)
tricky_simplenamespace.dummy = tricky_simplenamespace
tricky_capsule = types.CapsuleType
tricky_module = types.ModuleType("tricky_module", "docs")
tricky_module2 = types.ModuleType("tricky_module2\\x00", "docs\\x00")
tricky_genericalias = types.GenericAlias(tricky_capsule, (tricky_cell,))
tricky_dict = {tricky_capsule: tricky_cell, tricky_module: tricky_genericalias}
tricky_dict["tricky_dict"] = tricky_dict
tricky_mappingproxy = types.MappingProxyType(tricky_dict)


def tricky_function(*args, **kwargs):
    return tricky_function(*args, **kwargs)


tricky_lambda = lambda *args, **kwargs: tricky_lambda(*args, **kwargs)
tricky_classmethod = classmethod(tricky_lambda)
tricky_staticmethod = staticmethod(tricky_lambda)
tricky_property = property(tricky_lambda)
tricky_code = tricky_lambda.__code__
tricky_closure = tricky_code.co_freevars
tricky_classmethod_descriptor = types.ClassMethodDescriptorType


class TrickyDescriptor:
    def __get__(self, obj, objtype=None):
        return self

    def __set__(self, obj, value):
        obj.__dict__["_value"] = value

    def __delete__(self, obj):
        del obj.__dict__["_value"]


class TrickyMeta(type):
    @property
    def __signature__(self):
        raise AttributeError("Signature denied")


class TrickyClass(metaclass=TrickyMeta):
    tricky_descriptor = TrickyDescriptor()

    def __new__(cls, *args, **kwargs):
        return super().__new__(cls)

    def __init__(self, *args, **kwargs):
        self._value = None

    def __getattr__(self, name):
        return lambda *args, **kwargs: None


tricky_instance = TrickyClass()
tricky_frame = inspect.currentframe()
tricky_frame.f_builtins.update(tricky_dict)
tricky_frame.f_globals.update(tricky_dict)
tricky_frame.f_locals.update(tricky_dict)

try:
    1 / 0
except ZeroDivisionError as e:
    tricky_traceback = e.__traceback__

# tricky_generator = (x for x in itertools.count())  # Triggers too many free-threading segfaults
tricky_list = [[]] * 6 + []
tricky_list[0].append(tricky_list)
tricky_list[-1].append(tricky_list)
tricky_list.append(tricky_list)
tricky_list[0][0].append(tricky_list)
"""

type_names = ("list", "tuple", "dict")

class WritePythonCode(WriteCode):
    def __init__(self, parent, filename, module, module_name, threads=True, _async=True):
        WriteCode.__init__(self)
        self.filename = filename
        self.filenames = parent.filenames
        self.options = parent.options
        self.threads = threads
        self._async = _async
        self.hashable_argument_generators = (
            self.genNone,
            self.genBool,
            self.genSmallUint,
            self.genInt,
            self.genLetterDigit,
            self.genBytes,
            self.genString,
            self.genSurrogates,
            self.genAsciiString,
            self.genUnixPath,
            self.genFloat,
            self.genExistingFilename,
            self.genErrback,
            #            self.genOpenFile,
            self.genException,
            self.genRawString,
            self.genWeirdType,
            self.genWeirdType,
            self.genWeirdType,
        )
        self.simple_argument_generators = self.hashable_argument_generators + (
            self.genBufferObject,
            self.genInterestingValues,
            self.genWeirdClass,
            self.genWeirdInstance,
            self.genWeirdInstance,
            self.genWeirdType,
            self.genWeirdType,
            self.genWeirdUnion,
            self.genWeirdUnion,
            self.genTrickyObjects,
            self.genTrickyObjects,
            self.genTrickyObjects,
        )
        self.complex_argument_generators = (
            self.genList,
            self.genTuple,
            self.genDict,
            self.genTricky,
            self.genInterestingValues,
            self.genWeirdClass,
            self.genWeirdInstance,
            self.genWeirdInstance,
            self.genWeirdType,
            self.genWeirdType,
            self.genWeirdUnion,
            self.genWeirdUnion,
            self.genTrickyObjects,
            self.genTrickyObjects,
            self.genTrickyObjects,
        )
        self.smallint_generator = IntegerRangeGenerator(-19, 19)
        self.int_generator = IntegerGenerator(20)
        self.bytes_generator = BytesGenerator(0, 20)
        self.unicode_generator = UnicodeGenerator(1, 20, UNICODE_65535)
        self.ascii_generator = UnicodeGenerator(0, 20, ASCII8)
        self.unix_path_generator = UnixPathGenerator(100)
        self.letters_generator = UnicodeGenerator(
            1, 8, LETTERS | DECIMAL_DIGITS | ASCII8
        )
        self.float_int_generator = IntegerGenerator(4)
        self.float_float_generator = UnsignedGenerator(4)
        self.module = module
        self.module_name = module_name

        self.functions, self.classes, self.objects = self.getFunctions()
        if not self.functions and not self.classes and not self.objects:
            raise PythonFuzzerError(
                "Module %s has no function, no class and no object!" % self.module_name
            )

    def writePrint(self, level, arguments):
        if RUNNING_PYTHON3:
            code = "print (%s, file=stderr)" % arguments
        else:
            code = "print >>stderr, %s" % arguments
        self.write(level, code)

    def writeSource(self):
        self.createFile(self.filename)
        self.write(0, "from gc import collect")
        self.write(0, "from sys import stderr")
        self.write(0, "import inspect")
        self.write(0, "import sys")
        self.write(0, "from threading import Thread")
        self.write(0, "from unittest.mock import MagicMock")
        self.write(0, "import asyncio")
        self.writePrint(0, '"import %s"' % self.module_name)
        self.write(0, "import %s" % self.module_name)
        self.emptyLine()
        self.write(0, weird_classes)
        self.emptyLine()
        self.write(0, tricky_typing)
        self.emptyLine()
        self.write(0, tricky_objects)
        self.emptyLine()
        self.write(0, "def %s(*args, **kw):" % ERRBACK_NAME)
        self.write(1, "raise ValueError('error')")
        self.emptyLine()
        if self.threads:
            self.write(0, "alive = []")
        if self._async:
            self.write(0, "_async = []")
        self.write(0, "lst = list(range(10))")
        self.write(0, "lst.append(lst)")
        self.write(0, "class Liar1:")
        self.write(1, "def __eq__(self, other):")
        self.write(2, "return True")
        self.emptyLine()
        self.write(0, "class Liar2:")
        self.write(1, "def __eq__(self, other):")
        self.write(2, "return False")
        self.emptyLine()
        self.write(0, "liar1, liar2 = Liar1(), Liar2()")
        self.emptyLine()
        self.write(
            0,
            "\nclass Evil:\n    def __eq__(self, other):\n"
            "        for attr in dir(other):\n"
            "            try:\n"
            "                other.__dict__[attr] = %s\n"
            "            except:\n"
            "                pass\n"
            "evil = Evil()" % ERRBACK_NAME,
        )
        self.emptyLine()
        # self.emptyLine()
        # self.write(0, mangle_obj)
        self.emptyLine()
        self.write(0, "def callMethod(prefix, object, name, *arguments):")
        level = self.addLevel(1)
        self.writeCallMethod()
        self.restoreLevel(level)
        self.emptyLine()

        self.write(0, "def callFunc(prefix, name, *arguments):")
        self.write(
            1, "return callMethod(prefix, %s, name, *arguments)" % self.module_name
        )
        self.emptyLine()

        self.write(0, "obj = %s" % self.module_name)

        self.writeCode(
            "", self.module, self.functions, self.classes, self.objects, 1, NB_CALL
        )
        self.emptyLine()
        if self.threads:
            self.write(0, "for obj in alive:")
            self.write(1, "try:")
            self.write(2, "print('START', obj)")
            self.write(2, "obj.start()")
            self.write(1, "except Exception:")
            self.write(2, "pass")
            self.write(0, "for obj in alive:")
            self.write(1, "try:")
            self.write(2, "print('JOIN', obj)")
            self.write(2, "obj.join()")
            self.write(1, "except Exception:")
            self.write(2, "pass")
            self.emptyLine()
        if self._async:
            self.write(0, "async def main_async():")
            self.write(1, "await asyncio.gather(*_async, return_exceptions=True)")
            self.emptyLine()
            self.write(0, "runner = asyncio.Runner()")
            self.write(0, "loop = runner.get_loop()")
            self.write(0, "loop.set_task_factory(asyncio.eager_task_factory)")
            self.write(0, "runner.run(main_async())")
            self.emptyLine()
        self.close()

    def writeCallMethod(self):
        self.write(0, 'funcname = "%s.%%s()" %% name' % self.module_name)
        self.write(0, 'message = "[%s] %s" % (prefix, funcname)')
        self.writePrint(0, "message")
        self.write(0, "try:")
        self.write(1, "func = getattr(object, name)")
        self.write(1, "for x in range(5):")
        self.write(2, "result = func(*arguments)")

        exceptions = "(Exception, SystemExit, KeyboardInterrupt)"
        if RUNNING_PYTHON3:
            self.write(0, "except %s as err:" % exceptions)
        else:
            self.write(0, "except %s, err:" % exceptions)
        self.write(1, "try:")
        self.write(2, "errmsg = repr(err)")
        self.write(1, "except ValueError as e:")
        self.write(2, "errmsg = repr(e)")
        if RUNNING_PYTHON3:
            self.write(1, "errmsg = errmsg.encode('ASCII', 'replace')")
        self.writePrint(
            1,
            '"[%s] %s => %s: %s" % (prefix, funcname, err.__class__.__name__, errmsg)',
        )
        self.write(1, "result = None")

        self.writePrint(0, '"[%s] -garbage collector-" % prefix')
        self.write(0, "collect()   # explicit call to the garbage collector")
        if self.threads:
            self.write(0, "try:")
            self.write(1, "if result:")
            self.write(2, "alive.append(Thread(target=func, args=arguments, name=message))")
            self.write(0, "except:")
            self.write(1, "pass")
        self.write(0, "return result")

    def getFunctions(self):
        classes = []
        functions = []
        objects = []
        try:
            blacklist = BLACKLIST[self.module_name]
        except KeyError:
            blacklist = set()
        blacklist |= METHOD_BLACKLIST

        names = set(dir(self.module))
        names -= {"__builtins__", "__doc__", "__file__", "__name__"}
        names -= {"True", "None", "False"}
        if EXCLUDE_EXCEPTIONS:
            names -= EXCEPTION_NAMES
        names -= blacklist
        for name in names:
            try:
                attr = getattr(self.module, name)
            except AttributeError:
                # attribute declared in __all__, but no declared?
                continue
            if isinstance(attr, (FunctionType, BuiltinFunctionType)):
                functions.append(name)
            elif isinstance(attr, type) or inspect.isclass(attr):
                classes.append(name)
            else:
                objects.append(name)
        return functions, classes, objects

    def getMethods(self, object, class_name):
        try:
            key = "%s:%s" % (self.module_name, class_name)
            blacklist = BLACKLIST[key]
        except KeyError:
            blacklist = set()
        blacklist |= METHOD_BLACKLIST
        methods = {}
        if type(object) in {int, str}:
            return methods
        is_exception = isinstance(object, type) and issubclass(object, BaseException)
        is_exception = is_exception or isinstance(object, BaseException)
        for name in dir(object):
            if name in blacklist:
                continue
            if (not self.options.test_private) and name.startswith("__"):
                continue
            if is_exception and name == "__init__":
                continue
            try:
                attr = getattr(object, name, None)
                if attr is None:
                    continue
                if not callable(attr):
                    continue
            except Exception:
                continue
            methods[name] = attr
        return methods

    def _createArgument(self, generators):
        callback = choice(generators)
        value = callback()
        for item in value:
            if not isinstance(item, text_type):
                raise ValueError("%s returned type %s" % (callback, type(item)))
        return value

    def createArgument(self):
        return self._createArgument(self.simple_argument_generators)

    def createHashableArgument(self):
        return self._createArgument(self.hashable_argument_generators)

    def createComplexArgument(self):
        if randint(0, 9) < 9:
            # 10%
            generators = self.complex_argument_generators
        else:
            # 90%
            generators = self.simple_argument_generators
        return self._createArgument(generators)

    def getNbArg(self, func, func_name, min_arg):
        try:
            # Known method of arguments?
            value = METHODS_NB_ARG[func_name]
            if isinstance(value, tuple):
                min_arg, max_arg = value
            else:
                min_arg = max_arg = value
            return min_arg, max_arg
        except KeyError:
            pass

        try:
            argspec = inspect.getfullargspec(func)
            has_self = 1 if "self" in argspec.args or "cls" in argspec.args else 0
            args = (len(argspec.args) - has_self) if argspec.args else 0
            defaults = (len(argspec.defaults) - has_self) if argspec.defaults else 0
            return args - defaults, args
        except TypeError:
            pass

        if PARSE_PROTOTYPE:
            # Try using the documentation
            args = parseDocumentation(func.__doc__, MAX_VAR_ARG)
            if args:
                return args
        return min_arg, MAX_ARG

    def callFunction(self, prefix, func_index, func_name, func, min_arg, obj_name=None):
        if func_name.lower() in {"abort", "systemerror", "fatal", "critical", "assert"}:
            return
        min_arg, max_arg = self.getNbArg(func, func_name, min_arg)

        if randint(0, 19) < 1:
            nb_arg = 0
        elif randint(0, 19) < 2:
            nb_arg = 1
        elif randint(0, 19) < 3:
            nb_arg = max_arg + 1
        elif min_arg == max_arg:
            nb_arg = min_arg
        else:
            nb_arg = randint(min_arg, max_arg)

        if prefix:
            prefix += str(1 + func_index)
            first_line = 'res = callMethod("%s", obj, "%s"' % (prefix, func_name)
        else:
            prefix = "f%s" % (1 + func_index)
            first_line = 'res = callFunc("%s", "%s"' % (prefix, func_name)
        if nb_arg:
            self.write(0, first_line + ",")
            level = self.addLevel(1)
            last_char = ","
            for index in xrange(nb_arg):
                if index == nb_arg - 1:
                    last_char = ")"
                self.writeArgument(1, last_char)
            self.restoreLevel(level)
        else:
            self.write(0, first_line + ")")
        if self.threads:
            self.emptyLine()
            first_line = "alive.append(Thread(target=obj.%s, name='%s', args=(" % (func_name, f"{prefix}:{func_name}")
            self.write(0, "if hasattr(obj, '%s'):" % (func_name,))
            if nb_arg:
                self.write(1, first_line)
                last_char = ","
                for index in xrange(nb_arg):
                    if index == nb_arg - 1:
                        last_char = ",)))"
                    self.writeArgument(1, last_char)
            else:
                self.write(1, first_line + ")))")
        if self._async:
            self.emptyLine()
            self.write(0, "async def %s_%s():" % (prefix, func_name))
            self.write(1, "print('Start async calling %s_%s')" % (prefix, func_name))
            self.write(1, "await asyncio.sleep(%s)" % (random.random() / 100))
            first_line = 'obj.%s(' % func_name
            if nb_arg:
                self.write(1, first_line)
                level = self.addLevel(1)
                last_char = ","
                for index in xrange(nb_arg):
                    if index == nb_arg - 1:
                        last_char = ")"
                    self.writeArgument(1, last_char)
                self.restoreLevel(level)
            else:
                self.write(1, first_line + ")")
            self.write(1, "print('End async calling %s_%s')" % (prefix, func_name))

            self.write(0, "_async.append(%s_%s())" % (prefix, func_name))
        self.emptyLine()

    def writeArgument(self, level, last_char=","):
        lines = self.createComplexArgument()
        lines[-1] += last_char
        for line in lines:
            self.write(level, line)

    def useClass(self, cls_index, cls, class_name):
        import inspect

        if class_name in CLASS_NB_ARG:
            min_args, max_args = CLASS_NB_ARG[class_name]
            nb_arg = randint(min_args, max_args)
        else:
            argspec = inspect.getfullargspec(cls.__init__)
            args = len(argspec.args) - 1 if argspec.args else 0
            defaults = len(argspec.defaults) if argspec.defaults else 0
            nb_arg = randint(args - defaults, args)

        prefix = "o%s" % (1 + cls_index)
        self.writePrint(0, '"[%s] Create object %s"' % (prefix, 1 + cls_index))

        obj_name = "obj"
        self.write(0, '%s = callFunc("%s", "%s",' % (obj_name, prefix, class_name))
        for index in xrange(nb_arg):
            self.write(2, "# argument %s/%s" % (1 + index, nb_arg))
            self.writeArgument(2)
        self.write(1, ")")
        # self.write(0, mangle_loop % nb_arg)
        methods = sorted(self.getMethods(cls, class_name).keys())
        if methods:
            self.write(0, "if obj is not None:")
            level = self.addLevel(1)
            self.writeCode(prefix + "m", cls, methods, tuple(), tuple(), 0, NB_METHOD)
            self.write(0, "del %s" % obj_name)
            self.writePrint(0, '"[%s] -garbage collector -"' % prefix)
            self.write(0, "collect()   # explicit call to the garbage collector")
            self.restoreLevel(level)
        self.emptyLine()

    def useObject(self, obj_index, obj, obj_name):
        prefix = "obj%s" % (1 + obj_index)
        self.writePrint(
            0,
            '"[%s] Call methods on object %s (%s)"' % (prefix, 1 + obj_index, obj_name),
        )
        self.write(0, "obj = %s.%s" % (self.module_name, obj_name))
        methods = self.getMethods(obj, obj_name)
        if methods:
            self.write(0, "if obj is not None:")
            level = self.addLevel(1)
            self.writeCode(
                prefix + "m",
                obj,
                sorted(methods.keys()),
                tuple(),
                tuple(),
                0,
                NB_METHOD,
                obj_name,
            )
            self.writePrint(0, '"[%s] -garbage collector -"' % prefix)
            self.write(0, "collect()   # explicit call to the garbage collector")
            self.restoreLevel(level)
        self.emptyLine()

    def writeCode(
        self,
        prefix,
        object,
        functions,
        classes,
        objects,
        func_min_arg,
        nb_call,
        obj_name=None,
    ):
        if functions:
            for index in xrange(nb_call):
                func_name = choice(functions)
                func = getattr(object, func_name)
                self.callFunction(
                    prefix, index, func_name, func, func_min_arg, obj_name
                )
        if classes:
            self.nb_class = NB_CLASS
            for index in xrange(self.nb_class):
                class_name = choice(classes)
                cls = getattr(object, class_name)
                self.useClass(index, cls, class_name)
        if objects:
            for index in xrange(min(len(objects) * 2, 100)):
                object_name = choice(objects)
                obj = getattr(object, object_name)
                if object_name in OBJECT_BLACKLIST or isinstance(obj, ModuleType):
                    continue
                self.useObject(index, obj, object_name)

    def genNone(self):
        return ["None"]

    def genTricky(self):
        return [
            choice(
                [
                    "liar1",
                    "liar2",
                    "lst",
                    "lambda *args, **kwargs: 1/0",
                    "int",
                    "type",
                    "object()",
                    "[[[[[[[[[[[[[[]]]]]]]]]]]]]]",
                    "MagicMock()",
                    "Evil()",
                    "MagicMock",
                    "Evil",
                    "Liar1",
                    "Liar2",
                ]
            )
        ]

    def genBool(self):
        if randint(0, 1) == 1:
            return ["True"]
        else:
            return ["False"]

    def genSmallUint(self):
        return [self.smallint_generator.createValue()]

    def genInt(self):
        return [self.int_generator.createValue()]

    def genBytes(self):
        # Bytes string
        bytes = self.bytes_generator.createValue()
        if RUNNING_PYTHON3:
            text = "".join("\\x%02X" % byte for byte in bytes)
            text = 'b"%s"' % text
        else:
            text = "".join("\\x%02X" % ord(byte) for byte in bytes)
            text = '"%s"' % text
        return [text]

    def genUnixPath(self):
        path = self.unix_path_generator.createValue()
        return ['"%s"' % path]

    def _genUnicode(self, generator):
        # (Unicode) character string
        text = generator.createValue()
        text = escapeUnicode(text)
        if RUNNING_PYTHON3:
            text = '"%s"' % text
        else:
            text = 'u"%s"' % text
        return [text]

    def genLetterDigit(self):
        return self._genUnicode(self.letters_generator)

    def genString(self):
        return self._genUnicode(self.unicode_generator)

    def genRawString(self):
        sequences = (
            [r"\d", r"\D", r"\w", r"\W", r"\s", r"\S", r"\b", r"\B", r"\A", r"\Z"]
            + sorted(LETTERS)
            + ["."] * 10
        )
        special = ["+", "?", "*"]
        result = []
        for x in range(randint(3, 20)):
            result.append("".join(sample(sequences, randint(1, 3))))
            if randint(0, 9) > 8:
                result.append(choice(special))
        return [f'r"{"".join(result)}"']

    def genSurrogates(self):
        text = choice(SURROGATES)
        return [text]

    def genInterestingValues(self):
        interesting = choice(INTERESTING)
        return [interesting]

    def genTrickyObjects(self):
        tricky = choice(tricky_objects_names)
        return [tricky]

    def genWeirdClass(self):
        weird_class_name = choice(weird_names)
        return [f"weird_classes['{weird_class_name}']"]

    def genWeirdInstance(self):
        weird_class_name = choice(weird_instance_names)
        return [f"weird_instances['{weird_class_name}']"]

    def genWeirdType(self):
        weird_class_name = choice(weird_names)
        type_name = choice(type_names)
        return [f"{type_name}[weird_classes['{weird_class_name}']]"]

    def genWeirdUnion(self):
        weird_class_name1 = choice(weird_names)
        weird_class_name2 = choice(weird_names)
        type_name = choice(type_names)
        return [f"{type_name}[weird_classes['{weird_class_name1}']] | weird_classes['{weird_class_name2}'] | big_union"]

    def genBufferObject(self):
        text = choice(BUFFER_OBJECTS)
        return [text]

    def genAsciiString(self):
        return self._genUnicode(self.ascii_generator)

    def genFloat(self):
        int_part = self.float_int_generator.createValue()
        float_part = self.float_float_generator.createValue()
        return ["%s.%s" % (int_part, float_part)]

    def genExistingFilename(self):
        filename = choice(self.filenames)
        return ["'%s'" % filename]

    def genErrback(self):
        return ["%s" % ERRBACK_NAME]

    def genOpenFile(self):
        filename = choice(self.filenames)
        if RUNNING_PYTHON3:
            instr = "open('%s')" % filename
        else:
            instr = "open(u'%s')" % filename
        return [instr]

    def genException(self):
        return ["Exception('pouet')"]

    def _genList(self, open_text, close_text, empty, is_dict=False):
        # 90% of the time generate values of the same type
        same_type = randint(0, 9) != 0
        nb_item = randint(0, 9)
        if not nb_item:
            return [empty]
        items = []
        if same_type:
            if is_dict:
                key_callback = choice(self.hashable_argument_generators)
            value_callback = choice(self.simple_argument_generators)
            for index in xrange(nb_item):
                if is_dict:
                    item = self.createDictItem(key_callback, value_callback)
                else:
                    item = value_callback()
                items.append(item)
        else:
            for index in xrange(nb_item):
                if is_dict:
                    item = self.createDictItem()
                else:
                    item = self.createArgument()
                items.append(item)
        lines = []
        for item_index, item_lines in enumerate(items):
            if item_index:
                lines[-1] += ","
                for index, line in enumerate(item_lines):
                    # Add ' ' suffix to all lines
                    item_lines[index] = " " + line
            lines.extend(item_lines)
        if nb_item == 1 and empty == "tuple()":
            lines[-1] += ","
        lines[0] = open_text + lines[0]
        lines[-1] += close_text
        return lines

    def createDictItem(self, key_callback=None, value_callback=None):
        if key_callback:
            key = key_callback()
        else:
            key = self.createHashableArgument()
        if value_callback:
            value = value_callback()
        else:
            value = self.createArgument()
        key[-1] += ": " + value[0]
        key.extend(value[1:])
        return key

    def genList(self):
        return self._genList("[", "]", "[]")

    def genTuple(self):
        return self._genList("(", ")", "tuple()")

    def genDict(self):
        return self._genList("{", "}", "{}", True)


def parseArguments(arguments, defaults):
    for arg in arguments.split(","):
        arg = arg.strip(" \n[]")
        if not arg:
            continue
        if "=" in arg:
            arg, value = arg.split("=", 1)
            defaults[arg] = value
        yield arg


def parsePrototype(doc):
    r"""
    >>> parsePrototype("test([x])")
    ((), None, ('x',), {})
    >>> parsePrototype('dump(obj, file, protocol=0)')
    (('obj', 'file'), None, ('protocol',), {'protocol': '0'})
    >>> parsePrototype('setitimer(which, seconds[, interval])')
    (('which', 'seconds'), None, ('interval',), {})
    >>> parsePrototype("decompress(string[, wbits[, bufsize]])")
    (('string',), None, ('wbits', 'bufsize'), {})
    >>> parsePrototype("decompress(string,\nwbits)")
    (('string', 'wbits'), None, (), {})
    >>> parsePrototype("get_referents(*objs)")
    ((), '*objs', (), {})
    >>> parsePrototype("nothing")
    """
    if not doc:
        return None
    if not isinstance(doc, string_types):
        return None
    doc = doc.strip()
    match = PROTOTYPE_REGEX.match(doc)
    if not match:
        return None
    arguments = match.group(1)
    if arguments == "...":
        return None
    defaults = {}
    vararg = None
    varkw = tuple()
    if "[" in arguments:
        arguments, varkw = arguments.split("[", 1)
        arguments = tuple(parseArguments(arguments, defaults))
        varkw = tuple(parseArguments(varkw, defaults))
    else:
        arguments = tuple(parseArguments(arguments, defaults))

    # Argument with default value? => varkw
    move = None
    for index in xrange(len(arguments) - 1, -1, -1):
        arg = arguments[index]
        if arg not in defaults:
            break
        move = index
    if move is not None:
        varkw = arguments[move:] + varkw
        arguments = arguments[:move]

    if arguments and arguments[-1].startswith("*"):
        vararg = arguments[-1]
        arguments = arguments[:-1]
    return arguments, vararg, varkw, defaults


def parseDocumentation(doc, max_var_arg):
    """
    Arguments:
     - doc: documentation string
     - max_var_arg: maximum number of arguments for variable argument,
       eg. test(*args).
    """
    prototype = parsePrototype(doc)
    if not prototype:
        return None

    args, varargs, varkw, defaults = prototype
    min_arg = len(args)
    max_arg = min_arg + len(varkw)
    if varargs:
        max_arg += max_var_arg
    return min_arg, max_arg


def remove_logging_pycache():
    """Remove stale logging __pycache__ that causes logging errors."""
    import importlib
    import logging
    import pathlib

    pycache = pathlib.Path(logging.__file__).parent / "__pycache__"
    for entry in pycache.iterdir():
        try:
            entry.unlink()
        except Exception:
            pass
    try:
        pycache.rmdir()
    except Exception:
        pass
    importlib.reload(logging)


def print_running_time():
    raw_utime = resource.getrusage(resource.RUSAGE_SELF).ru_utime
    user_time = str(datetime.timedelta(0, round(raw_utime, 2)))
    total_time = str(datetime.timedelta(0, round(time.time() - time_start, 2)))
    return f"\nRunning time: {total_time[:-4]}\nUser time:    {user_time[:-4]}"

if __name__ == "__main__":
    time_start = time.time()
    remove_logging_pycache()
    Fuzzer().main()
